<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>KAMITSUBAKI CARD GAME 一人回し用シミュレーター</title>
    <style>
        :root {
            --card-width: 65px;
            --card-height: 91px;
            --zone-bg: rgba(0, 0, 0, 0.2);
            --border-color: rgba(255, 255, 255, 0.3);
        }
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background-color: #1a1a1d; color: #fff;
            font-family: 'Yu Gothic', 'Hiragino Kaku Gothic ProN', Meiryo, sans-serif;
            overflow: hidden; user-select: none; -webkit-user-select: none;
        }
        #game-container { width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; }
        .screen { width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 20px; box-sizing: border-box; }
        #deck-input-screen { background-color: #2c2f33; }
        #deck-input-screen h1 { font-size: 1.2rem; margin-bottom: 15px; }
        #deck-string { width: 90%; max-width: 500px; height: 150px; font-size: 1rem; padding: 10px; margin-bottom: 15px; background-color: #40444b; border: 1px solid var(--border-color); color: #fff; }
        #start-game-btn { padding: 12px 25px; font-size: 1.1rem; cursor: pointer; background-color: #c90063; border: none; color: white; border-radius: 5px; }

        #game-board { display: none; width: 100%; height: 100%; flex-direction: column; }
        #main-area { display: flex; flex-grow: 1; height: calc(100% - var(--card-height) - 10px); }
        #left-column { display: flex; flex-direction: column; justify-content: space-between; padding: 5px; gap: 10px; }
        #center-column { flex-grow: 1; display: flex; flex-direction: column; padding: 5px; gap: 5px; }
        #right-column { display: flex; flex-direction: column; align-items: center; padding: 10px; gap: 8px; }

        .zone { border: 1px solid var(--border-color); border-radius: 5px; background-color: var(--zone-bg); position: relative; }
        .zone-title { position: absolute; top: -10px; left: 5px; background: #1a1a1d; padding: 0 5px; font-size: 0.8em; color: #ccc; z-index: 10; }
        .pile-zone { width: calc(var(--card-width) + 10px); height: calc(var(--card-height) + 10px); cursor: pointer; }
        #stage-zone, #field-zone { flex-grow: 1; display: flex; flex-wrap: wrap; align-content: flex-start; gap: 5px; padding: 5px; }
        #hand-zone { width: 100%; height: calc(var(--card-height) + 10px); border-top: 1px solid var(--border-color); display: flex; justify-content: center; align-items: center; gap: 2px; padding: 5px 0; }
        .pile-zone .card { position: absolute; top: 5px; left: 5px; pointer-events: none; }
        .pile-zone .card:nth-child(2) { transform: translate(1px, 1px); }
        .pile-zone .card:nth-child(3) { transform: translate(2px, 2px); }
        .pile-zone .card:nth-child(4) { transform: translate(3px, 3px); }
        .zone-count { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 2rem; font-weight: bold; color: white; text-shadow: 0 0 5px black, 0 0 5px black; pointer-events: none; }

        .card { width: var(--card-width); height: var(--card-height); background-size: cover; background-position: center; background-repeat: no-repeat; border-radius: 4px; transition: transform 0.2s ease, box-shadow 0.2s ease; cursor: grab; touch-action: none; }
        .card.dragging { position: fixed; z-index: 3000; cursor: grabbing; box-shadow: 0 0 15px rgba(255, 255, 255, 0.5); pointer-events: none; transition: none; }
        .card.standby { transform: rotate(90deg); }
        .zone .card.standby { margin: 13px -13px; }

        .counter { background-color: var(--zone-bg); padding: 5px 10px; border-radius: 5px; text-align: center; width: 120px; }
        .counter-label { font-size: 0.9rem; }
        .counter-value { font-size: 1.5rem; font-weight: bold; margin: 0 10px; }
        .counter-controls { display: flex; justify-content: center; align-items: center; }
        .counter-btn { font-size: 1.5rem; width: 30px; height: 30px; line-height: 30px; background: none; border: 1px solid var(--border-color); color: #fff; cursor: pointer; border-radius: 50%; }
        .action-btn { padding: 8px 10px; font-size: 0.9rem; cursor: pointer; background-color: #3a3f44; border: 1px solid var(--border-color); color: white; border-radius: 5px; width: 120px; margin-top: auto; }
        #reset-btn { margin-top: 5px; }

        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); z-index: 2000; display: none; justify-content: center; align-items: center; }
        .modal-content { background-color: #2c2f33; padding: 15px; border-radius: 10px; max-width: 95%; max-height: 90%; display: flex; flex-direction: column; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .modal-title { font-size: 1.2rem; }
        .modal-close-btn { font-size: 1.5rem; cursor: pointer; }
        .modal-body { overflow-y: auto; display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; padding: 10px; }

        #card-zoom-overlay { z-index: 4000; pointer-events: none; }
        #card-zoom-view { width: calc(var(--card-width) * 4); height: calc(var(--card-height) * 4); background-size: contain; background-position: center; background-repeat: no-repeat; border-radius: 16px; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        
        .overlay-zone-container {
            position: fixed;
            top: 50%; left: 50%; transform: translate(-50%, -50%); /* Centered */
            width: 80%; max-width: 800px; z-index: 500;
            background-color: rgba(40, 40, 40, 0.95); border: 1px solid #c90063;
            border-radius: 10px; padding: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            display: none;
        }
        .overlay-zone-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .overlay-zone-controls button { margin-left: 5px; font-size: 0.8rem; padding: 4px 8px; }
        .overlay-card-area { min-height: calc(var(--card-height) + 10px); display: flex; flex-wrap: wrap; gap: 5px; padding: 5px; }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="deck-input-screen" class="screen">
            <h1>KAMITSUBAKI CARD GAME</h1>
            <p>デッキリストを / 区切りで入力してください</p>
            <textarea id="deck-string" placeholder="例: AA-01/AA-01/AA-02/..."></textarea>
            <button id="start-game-btn">ゲーム開始</button>
        </div>
        <div id="game-board" class="screen">
            <div id="main-area">
                <div id="left-column">
                    <div id="deck-zone" class="zone pile-zone drop-zone" data-zone-id="deck"><div class="zone-title">山札</div></div>
                    <div id="trash-zone" class="zone pile-zone drop-zone" data-zone-id="trash"><div class="zone-title">トラッシュ</div></div>
                    <div id="vol-noise-zone" class="zone pile-zone drop-zone" data-zone-id="volNoise"><div class="zone-title">VOLノイズ</div></div>
                </div>
                <div id="center-column">
                    <div id="stage-zone" class="zone drop-zone" data-zone-id="stage"><div class="zone-title">ステージ</div></div>
                    <div id="field-zone" class="zone drop-zone" data-zone-id="field"><div class="zone-title">場</div></div>
                </div>
                <div id="right-column">
                    <div class="counter"><div class="counter-label">VOL</div><div class="counter-controls"><button class="counter-btn" data-counter="vol" data-amount="-1">-</button><span id="vol-value" class="counter-value">0</span><button class="counter-btn" data-counter="vol" data-amount="1">+</button></div></div>
                    <div class="counter"><div class="counter-label">魔力 α</div><div class="counter-controls"><button class="counter-btn" data-counter="manaAlpha" data-amount="-1">-</button><span id="mana-alpha-value" class="counter-value">0</span><button class="counter-btn" data-counter="manaAlpha" data-amount="1">+</button></div></div>
                    <div class="counter"><div class="counter-label">魔力 β</div><div class="counter-controls"><button class="counter-btn" data-counter="manaBeta" data-amount="-1">-</button><span id="mana-beta-value" class="counter-value">0</span><button class="counter-btn" data-counter="manaBeta" data-amount="1">+</button></div></div>
                    <div class="counter"><div class="counter-label">魔力 Ω</div><div class="counter-controls"><button class="counter-btn" data-counter="manaOmega" data-amount="-1">-</button><span id="mana-omega-value" class="counter-value">0</span><button class="counter-btn" data-counter="manaOmega" data-amount="1">+</button></div></div>
                    <div class="counter"><div class="counter-label">ターン</div><div class="counter-controls"><button class="counter-btn" data-counter="turn" data-amount="-1">-</button><span id="turn-value" class="counter-value">1</span><button class="counter-btn" data-counter="turn" data-amount="1">+</button></div></div>
                    <button id="shuffle-btn" class="action-btn">山札シャッフル</button>
                    <button id="deck-search-btn" class="action-btn">山札サーチ</button>
                    <button id="temp-zone-toggle-btn" class="action-btn">テンポラリ表示</button>
                    <button id="reset-btn" class="action-btn">リセット</button>
                </div>
            </div>
            <div id="hand-zone" class="zone drop-zone" data-zone-id="hand"></div>
        </div>
    </div>

    <div id="temporary-zone-container" class="overlay-zone-container"><div class="overlay-zone-header"><span>テンポラリーゾーン</span><div id="temporary-zone-controls"><button data-action="temp-to-trash">全てトラッシュへ</button><button data-action="temp-to-deck-shuffle">山札に戻しシャッフル</button><button data-action="temp-to-deck-bottom">山札の下へ</button></div></div><div id="temporary-zone-cards" class="overlay-card-area drop-zone" data-zone-id="temporary"></div></div>
    <div id="trash-view-container" class="overlay-zone-container"><div class="overlay-zone-header"><span>トラッシュ</span></div><div id="trash-view-cards" class="overlay-card-area drop-zone" data-zone-id="trash"></div></div>
    <div id="vol-noise-view-container" class="overlay-zone-container"><div class="overlay-zone-header"><span>VOLノイズ</span></div><div id="vol-noise-view-cards" class="overlay-card-area drop-zone" data-zone-id="volNoise"></div></div>

    <div id="modal-container" class="modal-overlay"><div class="modal-content"><div class="modal-header"><h2 id="modal-title"></h2><span id="modal-close-btn" class="modal-close-btn">&times;</span></div><div id="modal-body" class="modal-body"></div></div></div>
    <div id="card-zoom-overlay" class="modal-overlay"><div id="card-zoom-view"></div></div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const counters = { vol: document.getElementById('vol-value'), manaAlpha: document.getElementById('mana-alpha-value'), manaBeta: document.getElementById('mana-beta-value'), manaOmega: document.getElementById('mana-omega-value'), turn: document.getElementById('turn-value'), };
        let gameState = {};
        function initGameState(deckList = []) {
            gameState = {
                counters: { turn: 1, vol: 0, manaAlpha: 0, manaBeta: 0, manaOmega: 0 },
                zones: { deck: shuffle([...deckList]), hand: [], stage: [], field: [], trash: [], volNoise: [], temporary: [] }
            };
            // Draw 7 initial cards
            for(let i = 0; i < 7; i++) { if (gameState.zones.deck.length > 0) { gameState.zones.hand.push(gameState.zones.deck.pop()); } }
        }

        let draggedCardVisual = null, draggedCardData = null, sourceZone = null;
        let isDragging = false, longPressTimer = null, lastTap = 0, isPressing = false;
        const LONG_PRESS_DURATION = 300, DOUBLE_TAP_DELAY = 300;
        const CARD_IMAGE_PATH = 'cards/';

        function shuffle(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[array[i], array[j]] = [array[j], array[i]]; } return array; }
        function findCardFromState(cardId, zoneId) { const zone = gameState.zones[zoneId]; if (!zone) return null; if (['stage', 'field'].includes(zoneId)) return zone.find(c => c.cardId === cardId); return zone.find(id => id === cardId); }
        function removeCardFromState(cardData, zoneId) { if (!cardData || !zoneId) return; const zone = gameState.zones[zoneId]; const cardIdToRemove = cardData.cardId; const index = ['stage', 'field'].includes(zoneId) ? zone.findIndex(c => c.cardId === cardIdToRemove) : zone.indexOf(cardIdToRemove); if (index > -1) zone.splice(index, 1); }
        function addCardToState(cardData, zoneId) { if (!cardData || !zoneId) return; const zone = gameState.zones[zoneId]; if (['stage', 'field'].includes(zoneId)) { zone.push(cardData); } else { zone.push(cardData.cardId); } }
        
        function renderAll() {
            renderBoard();
            if (document.getElementById('trash-view-container').style.display === 'block') renderTrashView();
            if (document.getElementById('vol-noise-view-container').style.display === 'block') renderVolNoiseView();
            if (document.getElementById('temporary-zone-container').style.display === 'block') renderTempZone();
        }

        function renderBoard() {
            document.querySelectorAll('#game-board .card, #game-board .zone-count').forEach(el => el.remove());
            ['deck', 'trash', 'volNoise'].forEach(zoneId => {
                const zoneEl = document.getElementById(`${zoneId}-zone`);
                const zoneData = gameState.zones[zoneId];
                if (zoneData.length > 0) {
                    const topCards = zoneData.slice(-3);
                    topCards.forEach(cardId => zoneEl.appendChild(createCardElement(cardId, false, zoneId, 'none')));
                    const countEl = document.createElement('span');
                    countEl.className = 'zone-count';
                    countEl.textContent = zoneData.length;
                    zoneEl.appendChild(countEl);
                }
            });
            ['hand', 'stage', 'field'].forEach(zoneId => {
                const zoneEl = document.getElementById(`${zoneId}-zone`);
                gameState.zones[zoneId].forEach(card => {
                    const cardId = (typeof card === 'object') ? card.cardId : card;
                    const isStandby = (typeof card === 'object') ? card.isStandby : false;
                    zoneEl.appendChild(createCardElement(cardId, isStandby, zoneId, 'drag'));
                });
            });
            for (const counterId in counters) { counters[counterId].textContent = gameState.counters[counterId]; }
        }
        
        function createCardElement(cardId, isStandby, zoneId, interactiveType) {
            const cardEl = document.createElement('div');
            cardEl.className = 'card';
            cardEl.dataset.cardId = cardId;
            if (isStandby) cardEl.classList.add('standby');

            if(zoneId === 'deck' && interactiveType === 'none') {
                cardEl.style.backgroundImage = `url('${CARD_IMAGE_PATH}back.png')`;
            } else {
                cardEl.style.backgroundImage = `url('${CARD_IMAGE_PATH}${cardId}.png')`;
            }

            if (interactiveType === 'drag') {
                cardEl.addEventListener('mousedown', handlePressStart);
                cardEl.addEventListener('touchstart', handlePressStart, { passive: false });
                cardEl.addEventListener('dblclick', handleDoubleClick);
            } else if (interactiveType === 'click') {
                cardEl.addEventListener('click', (e) => {
                    const searchCardId = e.currentTarget.dataset.cardId;
                    const index = gameState.zones.deck.indexOf(searchCardId);
                    if (index > -1) gameState.zones.deck.splice(index, 1);
                    gameState.zones.hand.push(searchCardId);
                    document.getElementById('modal-container').style.display = 'none';
                    shuffle(gameState.zones.deck); renderAll();
                });
            }
            return cardEl;
        }

        function handlePressStart(e) {
            e.preventDefault();
            const element = e.currentTarget;
            sourceZone = element.closest('.drop-zone').dataset.zoneId;

            let cardId;
            const isPile = element.classList.contains('pile-zone');
            if (isPile) {
                if (gameState.zones[sourceZone].length === 0) return;
                cardId = gameState.zones[sourceZone].slice(-1)[0];
                draggedCardData = { cardId: cardId, isStandby: false };
            } else {
                cardId = element.dataset.cardId;
                const cardDataInState = findCardFromState(cardId, sourceZone);
                draggedCardData = (typeof cardDataInState === 'object') ? { ...cardDataInState } : { cardId: cardId, isStandby: false };
            }
            
            longPressTimer = setTimeout(() => { isPressing = false; isDragging = false; longPressTimer = null; showCardZoom(draggedCardData.cardId); }, LONG_PRESS_DURATION);
            const currentTime = new Date().getTime();
            if (!isPile && currentTime - lastTap < DOUBLE_TAP_DELAY) { clearTimeout(longPressTimer); handleDoubleClick(e); return; }
            lastTap = currentTime;

            const touch = e.touches ? e.touches[0] : e;
            const rect = element.getBoundingClientRect();
            let offsetX = touch.clientX - rect.left;
            let offsetY = touch.clientY - rect.top;
            if (isPile) { offsetX = rect.width / 2; offsetY = rect.height / 2; }
            let startX = touch.clientX; let startY = touch.clientY;
            isPressing = true;

            const onMove = (moveEvent) => {
                if (!isPressing) return;
                const moveX = (moveEvent.touches ? moveEvent.touches[0] : moveEvent).clientX;
                const moveY = (moveEvent.touches ? moveEvent.touches[0] : moveEvent).clientY;
                if (!isDragging && (Math.abs(moveX - startX) > 5 || Math.abs(moveY - startY) > 5)) {
                    isDragging = true; clearTimeout(longPressTimer); hideCardZoom();
                    removeCardFromState(draggedCardData, sourceZone);
                    draggedCardVisual = document.createElement('div');
                    draggedCardVisual.className = 'card dragging';
                    if (draggedCardData.isStandby) draggedCardVisual.classList.add('standby');
                    draggedCardVisual.style.backgroundImage = `url('${CARD_IMAGE_PATH}${draggedCardData.cardId}.png')`;
                    document.body.appendChild(draggedCardVisual);
                    renderAll();
                }
                if (isDragging) { draggedCardVisual.style.left = `${moveX - offsetX}px`; draggedCardVisual.style.top = `${moveY - offsetY}px`; }
            };
            const onEnd = (endEvent) => {
                clearTimeout(longPressTimer); isPressing = false;
                document.removeEventListener('mousemove', onMove); document.removeEventListener('touchmove', onMove);
                document.removeEventListener('mouseup', onEnd); document.removeEventListener('touchend', onEnd);
                if (isDragging) {
                    draggedCardVisual.style.pointerEvents = 'none';
                    const endX = (endEvent.changedTouches ? endEvent.changedTouches[0] : endEvent).clientX;
                    const endY = (endEvent.changedTouches ? endEvent.changedTouches[0] : endEvent).clientY;
                    const targetEl = document.elementFromPoint(endX, endY);
                    const targetZoneEl = targetEl ? targetEl.closest('.drop-zone') : null;
                    if (targetZoneEl) { addCardToState(draggedCardData, targetZoneEl.dataset.zoneId); } 
                    else { addCardToState(draggedCardData, sourceZone); }
                }
                if (draggedCardVisual) draggedCardVisual.remove();
                draggedCardVisual = null; draggedCardData = null; sourceZone = null; isDragging = false;
                renderAll();
            };
            document.addEventListener('mousemove', onMove); document.addEventListener('touchmove', onMove, { passive: false });
            document.addEventListener('mouseup', onEnd); document.addEventListener('touchend', onEnd);
        }

        function handleDoubleClick(e) { e.preventDefault(); const cardEl = e.currentTarget; const zoneId = cardEl.closest('.drop-zone')?.dataset.zoneId; if (!['stage', 'field'].includes(zoneId)) return; const card = findCardFromState(cardEl.dataset.cardId, zoneId); if (card) { card.isStandby = !card.isStandby; renderAll(); } }
        function showCardZoom(cardId) { document.getElementById('card-zoom-view').style.backgroundImage = `url('${CARD_IMAGE_PATH}${cardId}.png')`; document.getElementById('card-zoom-overlay').style.display = 'flex'; }
        function hideCardZoom() { document.getElementById('card-zoom-overlay').style.display = 'none'; }
        function renderTrashView() { const container = document.getElementById('trash-view-cards'); container.innerHTML = ''; gameState.zones.trash.forEach(cardId => container.appendChild(createCardElement(cardId, false, 'trash', 'drag'))); }
        function renderVolNoiseView() { const container = document.getElementById('vol-noise-view-cards'); container.innerHTML = ''; gameState.zones.volNoise.forEach(cardId => container.appendChild(createCardElement(cardId, false, 'volNoise', 'drag'))); }
        function renderTempZone() { const container = document.getElementById('temporary-zone-cards'); container.innerHTML = ''; gameState.zones.temporary.forEach(cardId => container.appendChild(createCardElement(cardId, false, 'temporary', 'drag'))); }

        function setupEventListeners() {
            document.getElementById('start-game-btn').addEventListener('click', () => {
                const deckList = document.getElementById('deck-string').value.trim().split('/').filter(id => id);
                if (deckList.length === 0) { alert('有効なデッキリストを入力してください。'); return; }
                initGameState(deckList);
                document.getElementById('deck-input-screen').style.display = 'none';
                document.getElementById('game-board').style.display = 'flex';
                renderAll();
            });
            document.getElementById('reset-btn').addEventListener('click', () => { if (confirm('ゲームをリセットしますか？')) window.location.reload(); });
            document.getElementById('shuffle-btn').addEventListener('click', () => { shuffle(gameState.zones.deck); renderAll(); alert('山札をシャッフルしました。'); });
            
            document.querySelectorAll('.counter-btn').forEach(btn => btn.addEventListener('click', () => { const counter = btn.dataset.counter; gameState.counters[counter] += parseInt(btn.dataset.amount, 10); if (gameState.counters[counter] < 0) gameState.counters[counter] = 0; renderAll(); }));

            // Deck drag/tap
            const deckZone = document.getElementById('deck-zone');
            deckZone.addEventListener('mousedown', handlePressStart);
            deckZone.addEventListener('touchstart', handlePressStart, { passive: false });
            deckZone.addEventListener('click', () => { if (!isDragging && gameState.zones.deck.length > 0) { gameState.zones.hand.push(gameState.zones.deck.pop()); renderAll(); } });

            // Deck Search
            document.getElementById('deck-search-btn').addEventListener('click', () => {
                const modalBody = document.getElementById('modal-body');
                modalBody.innerHTML = '';
                [...gameState.zones.deck].reverse().forEach(cardId => modalBody.appendChild(createCardElement(cardId, false, 'deck', 'click')));
                document.getElementById('modal-title').textContent = '山札サーチ';
                document.getElementById('modal-container').style.display = 'flex';
            });
            document.getElementById('modal-close-btn').addEventListener('click', () => { document.getElementById('modal-container').style.display = 'none'; });

            // Overlay View Toggles
            document.getElementById('trash-zone').addEventListener('click', () => { if(isDragging) return; const container = document.getElementById('trash-view-container'); const isHidden = container.style.display === 'none' || !container.style.display; if(isHidden) renderTrashView(); container.style.display = isHidden ? 'block' : 'none'; });
            document.getElementById('vol-noise-zone').addEventListener('click', () => { if(isDragging) return; const container = document.getElementById('vol-noise-view-container'); const isHidden = container.style.display === 'none' || !container.style.display; if(isHidden) renderVolNoiseView(); container.style.display = isHidden ? 'block' : 'none'; });
            
            const tempZoneContainer = document.getElementById('temporary-zone-container');
            document.getElementById('temp-zone-toggle-btn').addEventListener('click', () => { const isHidden = tempZoneContainer.style.display === 'none' || !tempZoneContainer.style.display; if(isHidden) renderTempZone(); tempZoneContainer.style.display = isHidden ? 'block' : 'none'; document.getElementById('temp-zone-toggle-btn').textContent = isHidden ? 'テンポラリ非表示' : 'テンポラリ表示'; });
            document.getElementById('temporary-zone-controls').addEventListener('click', (e) => { const action = e.target.dataset.action; const tempCards = [...gameState.zones.temporary]; if (tempCards.length === 0) return; if (action === 'temp-to-trash') gameState.zones.trash.push(...tempCards); if (action === 'temp-to-deck-shuffle') { gameState.zones.deck.push(...tempCards); shuffle(gameState.zones.deck); } if (action === 'temp-to-deck-bottom') gameState.zones.deck.unshift(...shuffle(tempCards)); gameState.zones.temporary = []; renderAll(); });
            
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.overlay-zone-container') && !e.target.closest('#trash-zone')) { document.getElementById('trash-view-container').style.display = 'none'; }
                if (!e.target.closest('.overlay-zone-container') && !e.target.closest('#vol-noise-zone')) { document.getElementById('vol-noise-view-container').style.display = 'none'; }
                const tempBtn = document.getElementById('temp-zone-toggle-btn');
                if (!e.target.closest('.overlay-zone-container') && e.target !== tempBtn) { if(tempZoneContainer.style.display === 'block') { tempZoneContainer.style.display = 'none'; tempBtn.textContent = 'テンポラリ表示'; } }
            });
        }
        
        initGameState();
        setupEventListeners();
    });
    </script>
</body>
</html>