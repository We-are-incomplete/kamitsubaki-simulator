<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>KAMITSUBAKI CARD GAME 一人回し用シミュレーター</title>
    <style>
        :root {
            --card-height: 19vh;
            --card-width: calc(var(--card-height) * 0.7);
            --zone-bg: rgba(0, 0, 0, 0.2);
            --border-color: rgba(255, 255, 255, 0.3);
        }
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background-color: #1a1a1d; color: #fff;
            font-family: 'Yu Gothic', 'Hiragino Kaku Gothic ProN', Meiryo, sans-serif;
            overflow: hidden; user-select: none; -webkit-user-select: none;
            background-image: url('item/wall.png'); /* 背景画像を指定 */
            background-size: cover; /* 画面全体に画像を拡大縮小 */
            background-repeat: no-repeat; /* 画像を繰り返さない */
        }
        #game-container { width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; }
        .screen { width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 1vh 2vw; box-sizing: border-box; }
        #deck-input-screen { background-color: #2c2f33; }
        #deck-input-screen h1 { font-size: 1.2rem; margin-bottom: 15px; }
        #deck-string { width: 90%; max-width: 500px; height: 150px; font-size: 1rem; padding: 10px; margin-bottom: 15px; background-color: #40444b; border: 1px solid var(--border-color); color: #fff; }
        #start-game-btn { padding: 12px 25px; font-size: 1.1rem; cursor: pointer; background-color: #c90063; border: none; color: white; border-radius: 5px; }

        #game-board { display: none; width: 100%; height: 100%; flex-direction: column; }
        #main-area { display: flex; flex-grow: 1; height: calc(100% - var(--card-height) - 2vh); gap: 1vw; }
        #left-column { display: flex; flex-direction: column; justify-content: space-around; padding: 5px; gap: 1.5vh; }
        #center-column { flex-grow: 1; display: flex; flex-direction: column; padding: 5px 0; gap: 1vh; }
        #right-column { display: flex; flex-direction: column; align-items: center; padding: 5px; gap: 1vh; /* justify-content: space-between; を削除 */ }

        .zone { border: 1px solid var(--border-color); border-radius: 5px; background-color: var(--zone-bg); position: relative; }
        .zone-title { position: absolute; top: -1.5vh; left: 5px; background: #1a1a1d; padding: 0 5px; font-size: 1.5vh; color: #ccc; z-index: 10; }
        .pile-zone { width: calc(var(--card-width) + 10px); height: calc(var(--card-height) + 10px); cursor: pointer; }
        
        #stage-zone, #direction-zone { display: flex; justify-content: space-around; align-items: center; flex-grow: 1; }
        .stage-column { position: relative; width: var(--card-width); height: calc(var(--card-height) * 2); }
        .card-slot { position: relative; width: var(--card-width); height: var(--card-height); border: 1px dashed var(--border-color); border-radius: 4px; box-sizing: border-box; }
        .stage-column .card-slot { position: absolute; left: 0; }
        .card-slot[data-slot-color="green"]  { top: 0; border-color: #28a745; z-index: 1; }
        .card-slot[data-slot-color="blue"]   { top: calc(var(--card-height) * 0.5); border-color: #007bff; z-index: 2; }
        .card-slot[data-slot-color="red"]    { top: calc(var(--card-height) * 1.0); border-color: #dc3545; z-index: 3; }
        #direction-zone .card-slot { border-color: #e83e8c; }
        .card-slot .card { position: absolute; top: 0; left: 0; }
        
        #hand-zone { width: 100%; height: calc(var(--card-height) + 2vh); border-top: 1px solid var(--border-color); display: flex; justify-content: center; align-items: center; gap: 0.5vw; padding: 1vh 0; }
        .pile-zone .card { position: absolute; top: 5px; left: 5px; pointer-events: none; }
        .pile-zone .card:nth-child(2) { transform: translate(1px, 1px); }
        .pile-zone .card:nth-child(3) { transform: translate(2px, 2px); }
        .zone-count { position: absolute; top: 20%; left: 50%; transform: translate(-50%, -50%); font-size: 4vh; font-weight: bold; color: white; text-shadow: 0 0 5px black, 0 0 5px black; pointer-events: none; }

        .card { width: var(--card-width); height: var(--card-height); background-size: cover; background-position: center; background-repeat: no-repeat; border-radius: 4px; transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease; cursor: grab; touch-action: none; transform-origin: center; }
        .card.dragging { position: fixed; z-index: 3000; cursor: grabbing; box-shadow: 0 0 15px rgba(255, 255, 255, 0.5); pointer-events: none; transition: none; }

        #card-zoom-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7); /* 半透明の背景 */
            display: none; /* 初期状態は非表示 */
            justify-content: center;
            align-items: center;
            z-index: 6000; /* 最前面に表示 */
            pointer-events: none; /* オーバーレイ自体はクリックイベントを透過 */
        }

        #zoomed-card-image {
            width: calc(var(--card-width) * 3); /* 通常のカードの3倍の幅 */
            height: calc(var(--card-height) * 3); /* 通常のカードの3倍の高さ */
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            border-radius: 8px; /* 少し角丸に */
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.7);
            transform: none !important; /* 回転やその他の変形を最優先で無効化 */
        }

        #trash-expanded-zone {
            display: none; /* 初期状態は非表示 */
            position: absolute; /* ゲームボードに対する絶対位置 */
            top: 50%; /* 盤面中央に配置 */
            left: 50%;
            transform: translate(-50%, -50%); /* 中央揃えのための調整 */
            width: 70vw; /* 盤面の幅に合わせて調整 */
            height: 60vh; /* 盤面の高さに合わせて調整 */
            max-width: 800px; /* 最大幅 */
            max-height: 500px; /* 最大高さ */
            background-color: rgba(40, 20, 60, 0.95); /* 少し濃い紫色の背景 */
            border: 2px solid var(--border-color);
            border-radius: 10px;
            padding: 15px;
            box-sizing: border-box;
            z-index: 2500; /* 他の要素より手前、ドラッグ中のカードよりは奥 */
            overflow-y: auto; /* 縦スクロール可能 */
            /* display: flex; はJSで制御するため、ここでは指定しないか、初期値のnoneを優先させる */
            flex-wrap: wrap; /* カードを折り返して表示 */
            align-items: flex-start; /* 上から配置 */
            justify-content: flex-start; /* 左から配置 */
            gap: 10px; /* カード間の隙間 */
        }

        #deck-expanded-zone { /* 山札展開ゾーンのスタイルを追加 */
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 70vw;
            height: 60vh;
            max-width: 800px;
            max-height: 500px;
            background-color: rgba(20, 40, 60, 0.95); /* トラッシュと少し色を変える例 (青系) */
            border: 2px solid var(--border-color);
            border-radius: 10px;
            padding: 15px;
            box-sizing: border-box;
            z-index: 2500;
            overflow-y: auto;
            flex-wrap: wrap;
            align-items: flex-start;
            justify-content: flex-start;
            gap: 10px;
        }

        #volnoise-expanded-zone { /* VOLノイズ展開ゾーンのスタイルを追加 */
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 70vw;
            height: 60vh;
            max-width: 800px;
            max-height: 500px;
            background-color: rgba(60, 20, 40, 0.95); /* さらに色を変える例 (赤紫系) */
            border: 2px solid var(--border-color);
            border-radius: 10px;
            padding: 15px;
            box-sizing: border-box;
            z-index: 2500;
            overflow-y: auto;
            flex-wrap: wrap;
            align-items: flex-start;
            justify-content: flex-start;
            gap: 10px;
        }

        #trash-expanded-zone .card {
            /* 展開ゾーン内のカードは元のサイズで表示 */
            width: calc(var(--card-width) * 0.8); /* 少し小さめに表示 */
            height: calc(var(--card-height) * 0.8);
            position: relative; 
            display: inline-block; 
            cursor: grab; /* ドラッグ可能を示すカーソルに変更 */
            margin: 0; /* 個別のマージンはgapで管理 */
        }

        #deck-expanded-zone .card { /* 山札展開ゾーン内のカードスタイルを追加 */
            width: calc(var(--card-width) * 0.8);
            height: calc(var(--card-height) * 0.8);
            position: relative; 
            display: inline-block; 
            cursor: grab;
            margin: 0;
        }

        #volnoise-expanded-zone .card { /* VOLノイズ展開ゾーン内のカードスタイルを追加 */
            width: calc(var(--card-width) * 0.8);
            height: calc(var(--card-height) * 0.8);
            position: relative; 
            display: inline-block; 
            cursor: grab;
            margin: 0;
        }

        #temporary-expanded-zone { /* テンポラリー展開ゾーンのスタイルを追加 */
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 75vw; /* 他より少し広めに */
            height: 70vh;
            max-width: 900px;
            max-height: 600px;
            background-color: rgba(30, 50, 30, 0.95); /* 緑系の背景 */
            border: 2px solid var(--border-color);
            border-radius: 10px;
            padding: 15px;
            box-sizing: border-box;
            z-index: 2500;
            overflow: hidden; /* スクロールはカードエリアで */
            flex-direction: column; /* コントロールとカードエリアを縦に並べる */
            gap: 10px;
        }

        .temporary-zone-controls {
            display: flex;
            justify-content: space-around;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        .temporary-zone-controls button {
            padding: 8px 12px;
            font-size: 0.9rem;
            cursor: pointer;
            background-color: #4CAF50;
            border: none;
            color: white;
            border-radius: 4px;
        }
        
        .temporary-zone-card-area { /* カード表示エリア */
            flex-grow: 1;
            overflow-y: auto;
            display: flex;
            flex-wrap: wrap;
            align-items: flex-start;
            justify-content: flex-start;
            gap: 10px;
            padding: 5px;
            background-color: rgba(0,0,0,0.1);
            border-radius: 5px;
        }

        #trash-expanded-zone .card {
            /* 展開ゾーン内のカードは元のサイズで表示 */
            width: calc(var(--card-width) * 0.8); /* 少し小さめに表示 */
            height: calc(var(--card-height) * 0.8);
            position: relative; 
            display: inline-block; 
            cursor: grab; /* ドラッグ可能を示すカーソルに変更 */
            margin: 0; /* 個別のマージンはgapで管理 */
        }

        #deck-expanded-zone .card { /* 山札展開ゾーン内のカードスタイルを追加 */
            width: calc(var(--card-width) * 0.8);
            height: calc(var(--card-height) * 0.8);
            position: relative; 
            display: inline-block; 
            cursor: grab;
            margin: 0;
        }

        #volnoise-expanded-zone .card { /* VOLノイズ展開ゾーン内のカードスタイルを追加 */
            width: calc(var(--card-width) * 0.8);
            height: calc(var(--card-height) * 0.8);
            position: relative; 
            display: inline-block; 
            cursor: grab;
            margin: 0;
        }

        #temporary-expanded-zone .card { /* テンポラリー展開ゾーン内のカードスタイル */
            width: calc(var(--card-width) * 0.8);
            height: calc(var(--card-height) * 0.8);
            position: relative; 
            display: inline-block; 
            cursor: grab;
            margin: 0;
        }

        #open-temporary-zone-btn { /* 左カラムのボタンのスタイル */
            padding: 10px 15px;
            font-size: 0.9rem;
            cursor: pointer;
            background-color: #28a745; /* 緑色 */
            border: none;
            color: white;
            border-radius: 5px;
            text-align: center;
            width: calc(var(--card-width) + 10px); /* pile-zone と同じ幅 */
            box-sizing: border-box;
        }

        .action-btn { /* 既存のaction-btnスタイルを汎用的に */
            padding: 10px 15px;
            font-size: 0.9rem;
            cursor: pointer;
            background-color: #007bff;
            border: none;
            color: white;
            border-radius: 5px;
            width: calc(var(--card-width) + 10px);
            box-sizing: border-box;
            margin-bottom: 5px; /* ボタン間のマージン調整 */
        }
        #turn-end-btn { /* ターンエンドボタン特有のスタイルがあればここに */
            background-color: #ffc107; /* 例: 警告色っぽい黄色 */
            color: black;
        }


        #reset-btn {
            margin-bottom: 10px; /* リセットボタンの下にスペースを追加 */
        }
        #change-mat-btn {
            padding: 10px 15px;
            font-size: 1rem;
            cursor: pointer;
            background-color: #6c757d; /* Bootstrapのsecondaryカラー */
            border: none;
            color: white;
            border-radius: 5px;
            margin-bottom: 10px; /* 他のボタンとの間隔 */
        }

        /* 山札とカウンターを横並びにする */
        .deck-counters-wrapper {
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }
        .counters-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        /* 右カラム内の新しいラッパー */
        .right-inner {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            width: 100%; /* 幅を100%に設定 */
        }

        /* ダイス結果表示エリアのスタイル */
        .dice-result {
            /* position: absolute; */ /* 絶対配置を削除 */
            /* top: 50%; */
            /* left: 50%; */
            transform: translate(-50%, -50%);
            width: 100px;
            height: 100px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            display: none;
            justify-content: center;
            align-items: center;
            font-size: 3rem;
            color: white;
            z-index: 2000;
            pointer-events: none;
            background-image: url('item/dice1.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            transition: background-image 0.1s ease-in-out, opacity 0.1s ease-in-out;
        }

        /* 複数のダイスを横に並べるためのコンテナ */
        #dice-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            /* gap: 10px;  ダイス間のスペース */
            justify-content: center; /* 中央寄せ */
            z-index: 2000;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="deck-input-screen" class="screen">
            <h1>KAMITSUBAKI CARD GAME</h1>
            <p>デッキリストを / 区切りで入力してください</p>
            <textarea id="deck-string" placeholder="例: AA-01/AA-01/AA-02/...">DA-26/DA-26/DA-26/DA-26/BS-34/BS-34/BS-34/BS-34/GS-19/GS-19/GS-19/GS-19/AS-1/AS-1/AS-1/AS-1/AS-3/AS-3/AS-3/AS-3/GS-41/GS-41/GS-41/GS-41/AD-2/AD-2/AD-2/AD-3/AD-3/AD-3/BD-8/BD-8/BD-8/BD-15/BD-15/BD-15/GD-12/GD-12/GD-12/GD-14/prmM-1/prmM-1/prmM-1/prmM-1/AM-1/AM-1/AM-1/AM-1/AM-7/AM-7/BM-2/BM-2/BM-3/BM-3/BM-3/BM-3/DM-22/DM-22/DM-22/DM-22</textarea>
            <button id="start-game-btn">ゲーム開始</button>
        </div>
        <div id="game-board" class="screen">
            <div id="main-area">
                <div id="left-column">
                    <div id="volNoise-zone" class="zone pile-zone drop-zone" data-zone-id="volNoise"><div class="zone-title">VOLノイズ</div></div>
                    <button id="open-temporary-zone-btn">テンポラリー</button>
                    <div id="trash-zone" class="zone pile-zone drop-zone" data-zone-id="trash"><div class="zone-title">トラッシュ</div></div>
                </div>
                <div id="center-column">
                    <div id="stage-zone" class="zone">
                        <div class="zone-title">ステージ</div>
                        <div class="stage-column"><div class="card-slot drop-zone" data-zone-id="stage" data-slot-index="0" data-slot-color="green"></div><div class="card-slot drop-zone" data-zone-id="stage" data-slot-index="0" data-slot-color="blue"></div><div class="card-slot drop-zone" data-zone-id="stage" data-slot-index="0" data-slot-color="red"></div></div>
                        <div class="stage-column"><div class="card-slot drop-zone" data-zone-id="stage" data-slot-index="1" data-slot-color="green"></div><div class="card-slot drop-zone" data-zone-id="stage" data-slot-index="1" data-slot-color="blue"></div><div class="card-slot drop-zone" data-zone-id="stage" data-slot-index="1" data-slot-color="red"></div></div>
                        <div class="stage-column"><div class="card-slot drop-zone" data-zone-id="stage" data-slot-index="2" data-slot-color="green"></div><div class="card-slot drop-zone" data-zone-id="stage" data-slot-index="2" data-slot-color="blue"></div><div class="card-slot drop-zone" data-zone-id="stage" data-slot-index="2" data-slot-color="red"></div></div>
                        <div class="stage-column"><div class="card-slot drop-zone" data-zone-id="stage" data-slot-index="3" data-slot-color="green"></div><div class="card-slot drop-zone" data-zone-id="stage" data-slot-index="3" data-slot-color="blue"></div><div class="card-slot drop-zone" data-zone-id="stage" data-slot-index="3" data-slot-color="red"></div></div>
                        <div class="stage-column"><div class="card-slot drop-zone" data-zone-id="stage" data-slot-index="4" data-slot-color="green"></div><div class="card-slot drop-zone" data-zone-id="stage" data-slot-index="4" data-slot-color="blue"></div><div class="card-slot drop-zone" data-zone-id="stage" data-slot-index="4" data-slot-color="red"></div></div>
                    </div>
                    <div id="direction-zone" class="zone">
                        <div class="zone-title">Direction</div>
                        <div class="card-slot drop-zone" data-zone-id="direction" data-slot-index="0"></div>
                        <div class="card-slot drop-zone" data-zone-id="direction" data-slot-index="1"></div>
                        <div class="card-slot drop-zone" data-zone-id="direction" data-slot-index="2"></div>
                        <div class="card-slot drop-zone" data-zone-id="direction" data-slot-index="3"></div>
                        <div class="card-slot drop-zone" data-zone-id="direction" data-slot-index="4"></div>
                    </div>
                </div>
                <div id="right-column">
                    <!-- 横並びラップ -->
                    <div class="right-inner" style="display:flex; align-items:flex-start; gap:10px;">
                        <!-- ボタン＋山札 -->
                        <div class="buttons-deck-wrapper" style="display:flex; flex-direction:column; align-items:center; gap:5px;">
                            <!-- アクションボタン群 -->
                            <button id="turn-end-btn" class="action-btn">ターンエンド</button>
                            <button id="shuffle-btn" class="action-btn">山札シャッフル</button>
                            <button id="search-deck-btn" class="action-btn">山札からサーチ</button>
                            <button id="search-volnoise-btn" class="action-btn">VOLノイズからサーチ</button>
                            <button id="move-hand-to-trash-btn" class="action-btn">手札を全てトラッシュ</button>
                            <button id="mulligan-btn" class="action-btn">マリガン</button>
                            <button id="reset-btn" class="action-btn">リセット</button>
                            <button id="change-mat-btn">プレイマット変更</button>
                            <button id="roll-dice-btn" class="action-btn">ダイスを振る</button>

                            <!-- 山札ゾーン -->
                            <div id="deck-zone" class="zone pile-zone drop-zone" data-zone-id="deck"><div class="zone-title">山札</div></div>
                            <button id="draw-bottom-deck-btn" class="action-btn">山札の下から1枚ドロー</button>
                        </div>
                        <!-- カウンター群 -->
                        <div class="counters-group" style="display:flex; flex-direction:column; gap:5px;">
                            <div class="counter"><div class="counter-label">VOL</div><div class="counter-controls"><button class="counter-btn" data-counter="vol" data-amount="-1">-</button><span id="vol-value" class="counter-value">0</span><button class="counter-btn" data-counter="vol" data-amount="1">+</button></div></div>
                            <div class="counter"><div class="counter-label">魔力 α</div><div class="counter-controls"><button class="counter-btn" data-counter="manaAlpha" data-amount="-1">-</button><span id="mana-alpha-value" class="counter-value">0</span><button class="counter-btn" data-counter="manaAlpha" data-amount="1">+</button></div></div>
                            <div class="counter"><div class="counter-label">魔力 β</div><div class="counter-controls"><button class="counter-btn" data-counter="manaBeta" data-amount="-1">-</button><span id="mana-beta-value" class="counter-value">0</span><button class="counter-btn" data-counter="manaBeta" data-amount="1">+</button></div></div>
                            <div class="counter"><div class="counter-label">魔力 Ω</div><div class="counter-controls"><button class="counter-btn" data-counter="manaOmega" data-amount="-1">-</button><span id="mana-omega-value" class="counter-value">0</span><button class="counter-btn" data-counter="manaOmega" data-amount="1">+</button></div></div>
                            <div class="counter"><div class="counter-label">ターン</div><div class="counter-controls"><button class="counter-btn" data-counter="turn" data-amount="-1">-</button><span id="turn-value" class="counter-value">1</span><button class="counter-btn" data-counter="turn" data-amount="1">+</button></div></div>
                        </div>
                    </div>
                </div>
            </div>
            <div id="hand-zone" class="zone drop-zone" data-zone-id="hand"></div>
            <div id="dice-container"></div>
        </div>
    </div>
    <div id="trash-expanded-zone"></div> {/* 展開用トラッシュゾーン */}
    <div id="deck-expanded-zone"></div> {/* 展開用山札ゾーン */}
    <div id="volnoise-expanded-zone"></div> {/* 展開用VOLノイズゾーン */}
    <div id="temporary-expanded-zone" class="drop-zone" data-zone-id="temporary">
        <div class="temporary-zone-controls">
            <button id="temp-to-trash-btn">全てトラッシュへ</button>
            <button id="temp-to-deck-shuffle-btn">山札に戻しシャッフル</button>
            <button id="temp-to-deck-bottom-btn">山札の下へ</button>
            <button id="temp-hand-to-temporary-btn">手札を全てここへ</button>
        </div>
        <div class="temporary-zone-card-area drop-zone" data-zone-id="temporary">
            {/* カードはここにレンダリングされる */}
        </div>
    </div>
    <div id="card-zoom-overlay">
        <div id="zoomed-card-image"></div>
    </div>
    
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const counters = {
            vol: document.getElementById('vol-value'),
            manaAlpha: document.getElementById('mana-alpha-value'),
            manaBeta: document.getElementById('mana-beta-value'),
            manaOmega: document.getElementById('mana-omega-value'),
            turn: document.getElementById('turn-value'),
        };
        let gameState = {};
        const CARD_IMAGE_PATH = 'cards/';
        const DOUBLE_TAP_THRESHOLD = 300;
        const LONG_PRESS_DELAY = 500; // 長押しとみなすまでの時間（ミリ秒）
        let lastTapTime = 0;
        let lastTapTargetCardId = null;
        let longPressTimer = null; // 長押しタイマーのIDを保持

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function initGameState(deckList = []) {
            const NUM_SLOTS = 5;
            gameState = {
                counters: { turn: 1, vol: 0, manaAlpha: 0, manaBeta: 0, manaOmega: 0 },
                zones: {
                    deck: shuffle([...deckList]),
                    hand: [],
                    stage: Array(NUM_SLOTS).fill(null).map(() => ({ red: [], blue: [], green: [] })),
                    direction: Array(NUM_SLOTS).fill(null).map(() => []),
                    trash: [],
                    volNoise: [], // VOLノイズ置き場を初期化
                    temporary: [], // テンポラリーゾーンを初期化
                }
            };
            for (let i = 0; i < 7; i++) {
                if (gameState.zones.deck.length > 0) {
                    gameState.zones.hand.push(gameState.zones.deck.pop());
                }
            }
        }

        function renderAll() {
            // Remove all cards and zone counts
            document.querySelectorAll('.card, .zone-count').forEach(el => el.remove());

            // Render deck, trash, and volNoise pile
            ['deck', 'trash', 'volNoise'].forEach(zoneId => {
                const zoneEl = document.getElementById(`${zoneId}-zone`);
                if (!zoneEl) {
                    console.error(`[RenderAll] Zone element with ID '${zoneId}-zone' not found.`);
                    return;
                }
                zoneEl.innerHTML = ''; // Clear the zone before re-rendering

                const zoneData = gameState.zones[zoneId];
                if (zoneData) { 
                    // if (zoneId === 'volNoise') { // VOLノイズゾーンの処理開始ログ (必要に応じてコメント解除)
                    //     console.log(`[RenderAll] Processing volNoise zone. Card count: ${zoneData.length}`);
                    // }
                    if (zoneData.length > 0) {
                        // パイルの一番上のカードIDを取得 (gameState.zonesの各パイルはカードID文字列の配列を想定)
                        const topCardDisplayId = zoneData.slice(-1)[0];
                        // if (zoneId === 'volNoise') console.log(`[RenderAll] volNoise has cards. Top card for display (should be back): ${topCardDisplayId}`);
                        zoneEl.appendChild(createCardElement(topCardDisplayId, false, zoneId, 'none'));
                    } 
                    // else { // カードがない場合は、以前はプレースホルダーを表示していたが、何も表示しないように変更
                        // zoneEl.appendChild(createCardElement(null, false, zoneId, 'none')); 
                    // }
                    const countEl = document.createElement('span');
                    countEl.className = 'zone-count';
                    countEl.textContent = zoneData.length;
                    zoneEl.appendChild(countEl);

                    // if (zoneId === 'volNoise') { // VOLノイズゾーンの処理完了後、中身を確認 (必要に応じてコメント解除)
                    //     console.log(`[RenderAll] volNoise-zone innerHTML after append:`, zoneEl.innerHTML);
                    //     const cardInVolNoise = zoneEl.querySelector('.card');
                    //     if (cardInVolNoise) {
                    //         console.log('[RenderAll] volNoise-zone .card style:', cardInVolNoise.style.backgroundImage);
                    //     } else {
                    //         console.log('[RenderAll] volNoise-zone .card not found after append.');
                    //     }
                    // }
                } else {
                    console.warn(`[RenderAll] gameState.zones.${zoneId} is undefined.`);
                }
            });

            // Render hand
            const handZone = document.getElementById('hand-zone');
            handZone.innerHTML = '';
            gameState.zones.hand.forEach(cardId => {
                handZone.appendChild(createCardElement(cardId, false, 'hand', 'drag'));
            });

            // Render direction
            gameState.zones.direction.forEach((cardArray, index) => {
                const slotEl = document.querySelector(`.card-slot[data-zone-id="direction"][data-slot-index="${index}"]`);
                if (slotEl && cardArray.length > 0) {
                    cardArray.forEach((card, i) => {
                        const cardElement = createCardElement(card.cardId, card.isStandby, 'direction', 'drag', index);
                        let transformString = `translate(${i * 2}px, ${i * 2}px)`;
                        if (card.isStandby) transformString += ' rotate(90deg)';
                        cardElement.style.transform = transformString;
                        cardElement.style.zIndex = i;
                        slotEl.appendChild(cardElement);
                    });
                }
            });

            // Render stage
            gameState.zones.stage.forEach((column, index) => {
                ['green', 'blue', 'red'].forEach(color => {
                    const cardArray = column[color];
                    const slotEl = document.querySelector(`.card-slot[data-zone-id="stage"][data-slot-index="${index}"][data-slot-color="${color}"]`);
                    if (slotEl && cardArray.length > 0) {
                        cardArray.forEach((card, i) => {
                            const cardElement = createCardElement(card.cardId, card.isStandby, 'stage', 'drag', index, color);
                            let transformString = '';
                            if (color === 'green') {
                                // 新しいカード(i = cardArray.length - 1)が一番手前(yOffset = 0)
                                // 古いカードほど奥に、より上にずれる
                                const yOffset = (i - (cardArray.length - 1)) * 30; // ずらす量を30pxに増加
                                transformString = `translate(0px, ${yOffset}px)`;
                            } else if (color === 'red') {
                                // 2枚目以降のカードを下に40pxずつずらす
                                const yOffset = i * 40;
                                transformString = `translate(0px, ${yOffset}px)`;
                            } else {
                                // 青スロットは既存の斜め重ね表示 (現状、青は1枚しか置けない想定だが、念のため)
                                transformString = `translate(${i * 2}px, ${i * 2}px)`;
                            }
                            
                            if (card.isStandby) transformString += ' rotate(90deg)';
                            cardElement.style.transform = transformString;
                            cardElement.style.zIndex = i; // zIndexで手前に表示
                            slotEl.appendChild(cardElement);
                        });
                    }
                });
            });

            // Update counters
            for (const counterId in counters) {
                counters[counterId].textContent = gameState.counters[counterId];
            }

            // Render expanded trash zone if it's active
            const trashExpandedZoneEl = document.getElementById('trash-expanded-zone');
            trashExpandedZoneEl.innerHTML = ''; // Clear previous cards
            if (trashExpandedZoneEl.style.display === 'flex') { 
                gameState.zones.trash.forEach(cardId => {
                    // 展開ゾーンのカードはドラッグ可能にする
                    const cardElement = createCardElement(cardId, false, 'trash-expanded', 'drag'); 
                    trashExpandedZoneEl.appendChild(cardElement);
                });
            }

            // Render expanded deck zone if it's active
            const deckExpandedZoneEl = document.getElementById('deck-expanded-zone');
            deckExpandedZoneEl.innerHTML = ''; // Clear previous cards
            if (deckExpandedZoneEl.style.display === 'flex') {
                // 山札の上から（配列の末尾から）順番に表示するために逆順でループ
                for (let i = gameState.zones.deck.length - 1; i >= 0; i--) {
                    const cardId = gameState.zones.deck[i];
                    // 山札展開ゾーンのカードもドラッグ可能にする
                    const cardElement = createCardElement(cardId, false, 'deck-expanded', 'drag');
                    deckExpandedZoneEl.appendChild(cardElement);
                }
            }

            // Render expanded volNoise zone if it's active
            const volNoiseExpandedZoneEl = document.getElementById('volnoise-expanded-zone');
            volNoiseExpandedZoneEl.innerHTML = ''; // Clear previous cards
            if (volNoiseExpandedZoneEl.style.display === 'flex') {
                gameState.zones.volNoise.forEach(cardId => {
                    // VOLノイズ展開ゾーンのカードもドラッグ可能にする
                    const cardElement = createCardElement(cardId, false, 'volnoise-expanded', 'drag');
                    volNoiseExpandedZoneEl.appendChild(cardElement);
                });
            }

            // Render expanded temporary zone if it's active
            const temporaryExpandedZoneEl = document.getElementById('temporary-expanded-zone');
            const temporaryCardAreaEl = temporaryExpandedZoneEl.querySelector('.temporary-zone-card-area');
            temporaryCardAreaEl.innerHTML = ''; // Clear previous cards
            if (temporaryExpandedZoneEl.style.display === 'flex') {
                gameState.zones.temporary.forEach(cardId => {
                    const cardElement = createCardElement(cardId, false, 'temporary-expanded', 'drag');
                    temporaryCardAreaEl.appendChild(cardElement);
                });
            }

            // Update temporary zone button text with card count
            const openTemporaryZoneBtn = document.getElementById('open-temporary-zone-btn');
            if (openTemporaryZoneBtn) {
                const tempCount = gameState.zones.temporary.length;
                if (tempCount > 0) {
                    openTemporaryZoneBtn.textContent = `テンポラリー (${tempCount})`;
                } else {
                    openTemporaryZoneBtn.textContent = 'テンポラリー';
                }
            }
        }

        function createCardElement(cardId, isStandby, zoneId, interactiveType, slotIndex, slotColor) {
            const cardEl = document.createElement('div');
            cardEl.className = 'card';
            // cardIdがオブジェクトの場合（stageやdirectionから）と文字列の場合（handやdeckから）を考慮
            const actualCardId = (typeof cardId === 'object' && cardId !== null) ? cardId.cardId : cardId;
            cardEl.dataset.cardId = actualCardId;

            // if (zoneId === 'volNoise' && interactiveType === 'none') { // 必要に応じてコメント解除
            //     console.log(`[CreateCardElement] For volNoise pile. actualCardId: "${actualCardId}", interactiveType: ${interactiveType}`);
            // }
            // デバッグログ: トラッシュのパイル表示時にactualCardIdを確認
            if (zoneId === 'trash' && interactiveType === 'none') {
                // console.log(`[CreateCardElement] Rendering trash pile card. actualCardId: "${actualCardId}", type: ${typeof actualCardId}`);
            }

            if ((zoneId === 'deck' || zoneId === 'volNoise') && interactiveType === 'none') { // 山札またはVOLノイズのパイル表示のみ裏面
                 cardEl.style.backgroundImage = `url('item/back.png')`;
                 // if (zoneId === 'volNoise') console.log('[CreateCardElement] volNoise: Set back.png (condition: deck/volNoise pile)');
            } else if (actualCardId && typeof actualCardId === 'string' && actualCardId.trim() !== '') { // actualCardId が null でなく、空でない有効な文字列の場合のみ表面画像を設定
                 cardEl.style.backgroundImage = `url('${CARD_IMAGE_PATH}${actualCardId}.png')`;
            } else {
                 // カードIDがない、または無効な場合（空のパイルゾーンのプレースホルダーや、actualCardIdが期待する文字列でない場合など）は裏面を表示
                 // if (zoneId === 'volNoise') console.log('[CreateCardElement] volNoise: Set back.png (condition: else - invalid actualCardId or not deck/volNoise pile)');
                 if (interactiveType === 'none' && zoneId === 'trash') { // トラッシュのパイル表示でactualCardIdが無効だった場合
                    // console.warn(`[CreateCardElement] Trash pile: actualCardId "${actualCardId}" was invalid or empty. Displaying back.png.`);
                 }
                 cardEl.style.backgroundImage = `url('item/back.png')`;
            }


            if (isStandby) cardEl.style.transform = 'rotate(90deg)';
            
            if (interactiveType === 'drag') {
                cardEl.addEventListener('mousedown', e => handlePressStart(e, cardEl, zoneId, slotIndex, slotColor));
                cardEl.addEventListener('touchstart', e => handlePressStart(e, cardEl, zoneId, slotIndex, slotColor), { passive: false });
            }
            
            // タップイベントは手札、ステージ、ディレクションのカードにのみ設定
            if (zoneId === 'hand' || zoneId === 'stage' || zoneId === 'direction') {
                 cardEl.addEventListener('click', e => handleTap(cardEl, { zoneId, slotIndex, slotColor, cardId: actualCardId }));
            }
            return cardEl;
        }

        function handlePressStart(e, element, zoneId, slotIndex, slotColor) {
            e.preventDefault();
            let isDragging = false;
            let draggedCardVisual = null;
            let draggedCardData = null;
            let sourceInfo = { zoneId, slotIndex, slotColor };
            let isPile = (element.classList.contains('pile-zone')); // pile-zoneクラスで判定

            if (isPile) {
                zoneId = element.dataset.zoneId; // pile-zoneからzoneIdを取得
                sourceInfo.zoneId = zoneId; // sourceInfoも更新
                if (gameState.zones[zoneId].length === 0) return;
                // パイルからドラッグする場合は一番上のカード
                const topCardId = gameState.zones[zoneId][gameState.zones[zoneId].length - 1];
                draggedCardData = { cardId: (typeof topCardId === 'object' ? topCardId.cardId : topCardId), isStandby: false };
            } else if (zoneId === 'hand') {
                draggedCardData = { cardId: element.dataset.cardId, isStandby: false };
            } else if (zoneId === 'direction') {
                const arr = gameState.zones.direction[slotIndex];
                if (!arr || arr.length === 0) return;
                draggedCardData = { ...arr[arr.length - 1] };
            } else if (zoneId === 'stage') {
                const arr = gameState.zones.stage[slotIndex][slotColor];
                if (!arr || arr.length === 0) return;
                draggedCardData = { ...arr[arr.length - 1] };
            } else if (zoneId === 'trash' || zoneId === 'trash-expanded') {
                draggedCardData = { cardId: element.dataset.cardId, isStandby: false };
                sourceInfo.zoneId = 'trash'; // gameStateでの削除元は'trash'として扱う
            } else if (zoneId === 'deck-expanded') { // 山札展開ゾーンからのドラッグ
                draggedCardData = { cardId: element.dataset.cardId, isStandby: false };
                sourceInfo.zoneId = 'deck'; // gameStateでの削除元は'deck'として扱う
            } else if (zoneId === 'volnoise-expanded') { // VOLノイズ展開ゾーンからのドラッグ
                draggedCardData = { cardId: element.dataset.cardId, isStandby: false };
                sourceInfo.zoneId = 'volNoise'; // gameStateでの削除元は'volNoise'として扱う
            } else if (zoneId === 'temporary-expanded') { // テンポラリー展開ゾーンからのドラッグ
                draggedCardData = { cardId: element.dataset.cardId, isStandby: false };
                sourceInfo.zoneId = 'temporary'; 
            }
            if (!draggedCardData && !isPile) { // パイルでない場合、カードデータがなければ終了
                 // console.log("No dragged card data for non-pile, exiting press start.");
                 return;
            }
            // パイルの場合、draggedCardDataは上で設定されるか、空ならreturn済み

            const touch = e.touches ? e.touches[0] : e;
            const rect = element.getBoundingClientRect();
            let offsetX = touch.clientX - rect.left;
            let offsetY = touch.clientY - rect.top;
            if (isPile) {
                offsetX = rect.width / 2;
                offsetY = rect.height / 2;
            }
            let startX = touch.clientX;
            let startY = touch.clientY;

            let longPressActionCompleted = false; // 長押しによる拡大表示が完了したかを示すフラグ

            // 長押しタイマーを開始
            clearTimeout(longPressTimer); // 既存のタイマーがあればクリア
            longPressTimer = setTimeout(() => {
                if (!isDragging && element.classList.contains('card') && !isPile) {
                    const cardIdToZoom = element.dataset.cardId;
                    const cardZoomOverlay = document.getElementById('card-zoom-overlay');
                    const zoomedCardImage = document.getElementById('zoomed-card-image');
                    if (cardIdToZoom && cardZoomOverlay && zoomedCardImage) {
                        zoomedCardImage.style.backgroundImage = `url('${CARD_IMAGE_PATH}${cardIdToZoom}.png')`;
                        cardZoomOverlay.style.display = 'flex';
                        longPressActionCompleted = true; // 長押しアクションが完了したことをマーク
                    }
                }
                longPressTimer = null; // タイマー実行後はクリア
            }, LONG_PRESS_DELAY);


            const onMove = (moveEvent) => {
                const moveX = (moveEvent.touches ? moveEvent.touches[0] : moveEvent).clientX;
                const moveY = (moveEvent.touches ? moveEvent.touches[0] : moveEvent).clientY;
                if (Math.abs(moveX - startX) > 5 || Math.abs(moveY - startY) > 5) { // 少しでも動いたら
                    if (longPressTimer) { // タイマーがまだ作動していればクリア
                        clearTimeout(longPressTimer);
                        longPressTimer = null;
                    }
                    // longPressActionCompleted はタイマーが発動しなければ false のまま
                    const cardZoomOverlay = document.getElementById('card-zoom-overlay');
                    if (cardZoomOverlay.style.display === 'flex') {
                        cardZoomOverlay.style.display = 'none'; // 拡大表示もキャンセル
                    }

                    if (!isDragging) { // ドラッグ開始の処理
                        isDragging = true;
                        if (!isPile && element) element.style.opacity = '0.5'; // elementが存在する場合のみ
                        
                        // draggedCardData がこの時点で必要
                        if (draggedCardData) { // draggedCardData が有効な場合のみビジュアルを作成
                            draggedCardVisual = document.createElement('div');
                            draggedCardVisual.className = 'card dragging';
                            draggedCardVisual.style.backgroundImage = `url('${CARD_IMAGE_PATH}${draggedCardData.cardId}.png')`;
                            if (draggedCardData.isStandby) draggedCardVisual.style.transform = 'rotate(90deg)';
                            document.body.appendChild(draggedCardVisual);
                        } else if (isPile) {
                            // パイルからのドラッグの場合、draggedCardDataは最初に設定されているはず
                            // もし空のパイルなら、そもそもここまで来ない (最初のifでreturn)
                        }
                    }
                }
                if (isDragging && draggedCardVisual) {
                    draggedCardVisual.style.left = `${moveX - offsetX}px`;
                    draggedCardVisual.style.top = `${moveY - offsetY}px`;
                }
            };

            const onEnd = (endEvent) => {
                if (longPressTimer) { // タイマーがまだ作動していれば（つまり、長押し完了前に終了した場合）
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                    // longPressActionCompleted は false のまま
                }
                // longPressTimerがnullでも、longPressActionCompletedがtrueなら長押しが完了している

                const cardZoomOverlay = document.getElementById('card-zoom-overlay');
                if (cardZoomOverlay.style.display === 'flex') {
                    cardZoomOverlay.style.display = 'none';
                }

                document.removeEventListener('mousemove', onMove);
                document.removeEventListener('touchmove', onMove);
                document.removeEventListener('mouseup', onEnd);
                document.removeEventListener('touchend', onEnd);
                if (!isPile && element) element.style.opacity = '1'; // elementが存在する場合のみ
                
                if (isDragging) {
                    if (draggedCardData) { // ドラッグデータがある場合のみ処理
                        removeCardFromState(draggedCardData, sourceInfo);
                        
                        const endX = (endEvent.changedTouches ? endEvent.changedTouches[0] : endEvent).clientX;
                        const endY = (endEvent.changedTouches ? endEvent.changedTouches[0] : endEvent).clientY;
                        const targetEl = document.elementFromPoint(endX, endY);
                        let dropped = false;
                        const targetSlot = targetEl ? targetEl.closest('.card-slot.drop-zone') : null;
                        const targetNonSlotZone = targetEl ? targetEl.closest('.zone.drop-zone:not(#stage-zone):not(#direction-zone):not(#temporary-expanded-zone), .temporary-zone-card-area.drop-zone') : null;
                        const targetExpandedTrash = targetEl ? targetEl.closest('#trash-expanded-zone') : null;
                        const targetTemporaryZone = targetEl ? (targetEl.closest('#temporary-expanded-zone') || targetEl.closest('.temporary-zone-card-area')) : null;

                        if (targetSlot) {
                            const targetInfo = {
                                zoneId: targetSlot.dataset.zoneId,
                                slotIndex: targetSlot.dataset.slotIndex,
                                slotColor: targetSlot.dataset.slotColor
                            };
                            if (addCardToState(draggedCardData, targetInfo)) {
                                dropped = true;
                            }
                        } else if (targetNonSlotZone) {
                            if (addCardToState(draggedCardData, { zoneId: targetNonSlotZone.dataset.zoneId })) {
                                dropped = true;
                            }
                        } else if (targetExpandedTrash && targetExpandedTrash.style.display === 'flex') {
                            if (addCardToState(draggedCardData, { zoneId: 'trash' })) {
                                dropped = true;
                            }
                        } else if (targetTemporaryZone && document.getElementById('temporary-expanded-zone').style.display === 'flex') {
                            if (addCardToState(draggedCardData, { zoneId: 'temporary' })) {
                                dropped = true;
                            }
                        }
                        
                        if (!dropped) { // いずれのドロップ先でも成功しなかった場合、元の場所に戻す
                            addCardToState(draggedCardData, sourceInfo); 
                        }
                    }
                    if (draggedCardVisual) draggedCardVisual.style.display = 'none'; // ドラッグ中のビジュアルを隠す
                } else {
                    // ドラッグでなければタップとして処理
                    // ただし、長押しアクションが完了した場合はタップ処理をスキップ
                    if (!longPressActionCompleted) {
                        if (isPile) {
                            handleTap(element, { zoneId: sourceInfo.zoneId }); // パイルゾーンのタップ
                        } else {
                            handleTap(element, sourceInfo); // カードのタップ
                        }
                    }
                }
                if (draggedCardVisual) draggedCardVisual.remove();
                renderAll();
            };

            document.addEventListener('mousemove', onMove);
            document.addEventListener('touchmove', onMove, { passive: false });
            document.addEventListener('mouseup', onEnd);
            document.addEventListener('touchend', onEnd);
        }

        function removeCardFromState(cardData, fromInfo) {
            if (!cardData || !fromInfo) return;
            const zoneId = fromInfo.zoneId; // 'trash-expanded'からドラッグした場合、ここは'trash'になる
            const cardIdToRemove = cardData.cardId;
            let slotArray;
            if (zoneId === 'direction') {
                slotArray = gameState.zones.direction[fromInfo.slotIndex];
            } else if (zoneId === 'stage') {
                slotArray = gameState.zones.stage[fromInfo.slotIndex][fromInfo.slotColor];
            }
            if (slotArray && slotArray.length > 0) {
                const topCard = slotArray[slotArray.length - 1];
                if (topCard.cardId === cardIdToRemove) slotArray.pop();
            } else if (zoneId !== 'direction' && zoneId !== 'stage') {
                const zone = gameState.zones[zoneId];
                if (!zone) return;
                const index = zone.indexOf(cardIdToRemove);
                if (index > -1) zone.splice(index, 1);
            }
        }

        function addCardToState(cardData, toInfo) {
            if (!cardData || !toInfo || !toInfo.zoneId) return false;
            const zoneId = toInfo.zoneId;
            const cardObject = { cardId: cardData.cardId, isStandby: false };

            if (zoneId === 'direction') {
                if (toInfo.slotIndex !== undefined) {
                    // ディレクションスロットに既にカードがある場合は追加しない
                    if (gameState.zones.direction[toInfo.slotIndex].length > 0) {
                        // console.log("Direction slot already full. Card not added.");
                        return false; 
                    }
                    gameState.zones.direction[toInfo.slotIndex].push(cardObject);
                    return true;
                }
                return false; // slotIndex が undefined の場合
            } else if (zoneId === 'stage') {
                if (toInfo.slotIndex !== undefined && toInfo.slotColor) {
                    if (toInfo.slotColor === 'blue') {
                        // 青スロットに既にカードがある場合は追加しない
                        if (gameState.zones.stage[toInfo.slotIndex][toInfo.slotColor].length > 0) {
                            // console.log("Blue stage slot already full. Card not added.");
                            return false;
                        }
                        cardObject.isStandby = true;
                    }
                    // 他の色（green, red）のスロットや、空の青スロットへの追加
                    gameState.zones.stage[toInfo.slotIndex][toInfo.slotColor].push(cardObject);
                    return true;
                }
                return false; // slotIndex または slotColor が undefined の場合
            } else {
                const zone = gameState.zones[zoneId];
                if (zone && typeof cardObject.cardId === 'string') {
                    zone.push(cardObject.cardId);
                    if (zoneId === 'volNoise') {
                        shuffle(gameState.zones.volNoise); // VOLノイズ置き場に追加されたらシャッフル
                    }
                    return true;
                }
                return false; // zone が無効、または cardId が文字列でない場合
            }
        }

        function handleTap(element, tapInfo) {
            const currentTime = new Date().getTime();
            const { zoneId, slotIndex, slotColor } = tapInfo;
            // elementがカードかゾーンかでcardIdの取得方法を変える
            const cardId = element.classList.contains('card') ? element.dataset.cardId : null;

            if (element.classList.contains('pile-zone') && zoneId === 'trash') {
                // トラッシュパイルゾーンがタップされた場合
                const trashExpandedZoneEl = document.getElementById('trash-expanded-zone');
                if (trashExpandedZoneEl.style.display === 'flex') { // 表示判定を 'flex' に
                    trashExpandedZoneEl.style.display = 'none';
                } else {
                    trashExpandedZoneEl.style.display = 'flex'; // 表示を 'flex' に
                }
                renderAll(); // 展開ゾーンのカードを再描画
                return; // 他のタップ処理は行わない
            }
            // 山札パイルゾーンがタップされた場合の処理は既存のまま (カードを引く)
            // 「山札からサーチ」ボタンの処理は setupEventListeners で個別に行う
            // 「VOLノイズからサーチ」ボタンの処理は setupEventListeners で個別に行う
            // 「テンポラリーゾーンを開く」ボタンの処理は setupEventListeners で個別に行う


            if (element.classList.contains('pile-zone')) {
                if (zoneId === 'deck' && gameState.zones.deck.length > 0) {
                    // テンポラリーゾーンが開いているか確認
                    const temporaryExpandedZoneEl = document.getElementById('temporary-expanded-zone');
                    if (temporaryExpandedZoneEl.style.display === 'flex') {
                        // テンポラリーゾーンにカードを追加
                        const topCard = gameState.zones.deck.pop();
                        if (topCard) {
                            gameState.zones.temporary.push(topCard);
                        }
                    } else {
                        // 通常通り手札にカードを追加
                        gameState.zones.hand.push(gameState.zones.deck.pop());
                    }
                } else if (zoneId === 'volNoise' && gameState.zones.volNoise && gameState.zones.volNoise.length > 0) {
                    // VOLノイズゾーンがタップされた場合
                    const topCard = gameState.zones.volNoise.pop();
                    if (topCard) { // stringのはずだが念のため確認
                        gameState.zones.hand.push(topCard);
                    }
                }
                lastTapTime = 0;
                lastTapTargetCardId = null;
            } else if (cardId) { // cardId が存在する場合のみ（カードのタップ）
                if (currentTime - lastTapTime <= DOUBLE_TAP_THRESHOLD && lastTapTargetCardId === cardId) {
                    // Double tap detected
                    // console.log('Double tap on card:', cardId);
                    // ここでカード拡大表示などの処理を将来的に追加可能
                    lastTapTime = 0;
                } else {
                    lastTapTime = currentTime;
                    lastTapTargetCardId = cardId;
                    // シングルタップ時の処理 (スタンバイ切り替えなど)
                    if (zoneId === 'direction' || zoneId === 'stage') {
                        let slotArray;
                        if (zoneId === 'direction') slotArray = gameState.zones.direction[slotIndex];
                        else if (zoneId === 'stage') slotArray = gameState.zones.stage[slotIndex][slotColor];
                        
                        if (slotArray && slotArray.length > 0) {
                            const topCard = slotArray[slotArray.length - 1];
                            if (cardId === topCard.cardId) { // タップされたカードがスタックの一番上か確認
                                topCard.isStandby = !topCard.isStandby;
                            }
                        }
                    }
                }
            }
            renderAll();
        }

        function mulliganHand() {
            if (gameState.zones.hand.length === 0) return;
            gameState.zones.deck = shuffle(gameState.zones.deck.concat(gameState.zones.hand));
            gameState.zones.hand = [];
            for (let i = 0; i < 7; i++) {
                if (gameState.zones.deck.length > 0) {
                    gameState.zones.hand.push(gameState.zones.deck.pop());
                }
            }
            renderAll();
        }

        function moveHandToTrash() {
            gameState.zones.trash = gameState.zones.trash.concat(gameState.zones.hand);
            gameState.zones.hand = [];
            renderAll();
        }

        function setupEventListeners() {
            document.getElementById('mulligan-btn').addEventListener('click', mulliganHand);
            document.getElementById('move-hand-to-trash-btn').addEventListener('click', moveHandToTrash);
            
            // パイルゾーンのイベントリスナー
            const trashZoneEl = document.getElementById('trash-zone');
            trashZoneEl.addEventListener('mousedown', e => handlePressStart(e, trashZoneEl, 'trash'));
            trashZoneEl.addEventListener('touchstart', e => handlePressStart(e, trashZoneEl, 'trash'), { passive: false });
            trashZoneEl.addEventListener('click', e => handleTap(trashZoneEl, { zoneId: 'trash' }));

            const deckZoneEl = document.getElementById('deck-zone');
            deckZoneEl.addEventListener('mousedown', e => handlePressStart(e, deckZoneEl, 'deck'));
            deckZoneEl.addEventListener('touchstart', e => handlePressStart(e, deckZoneEl, 'deck'), { passive: false });
            deckZoneEl.addEventListener('click', e => handleTap(deckZoneEl, { zoneId: 'deck' }));

            const volNoiseZoneEl = document.getElementById('volNoise-zone'); // IDを 'vol-noise-zone' から 'volNoise-zone' に修正
            volNoiseZoneEl.addEventListener('mousedown', e => handlePressStart(e, volNoiseZoneEl, 'volNoise'));
            volNoiseZoneEl.addEventListener('touchstart', e => handlePressStart(e, volNoiseZoneEl, 'volNoise'), { passive: false });
            volNoiseZoneEl.addEventListener('click', e => handleTap(volNoiseZoneEl, { zoneId: 'volNoise' }));

            document.querySelectorAll('.counter-btn').forEach(btn => btn.addEventListener('click', () => {
                const counter = btn.dataset.counter;
                gameState.counters[counter] += parseInt(btn.dataset.amount, 10);
                if (gameState.counters[counter] < 0) gameState.counters[counter] = 0;
                renderAll();
            }));
            document.getElementById('shuffle-btn').addEventListener('click', () => {
                shuffle(gameState.zones.deck);
                renderAll();
                alert('山札をシャッフルしました。');
            });
            document.getElementById('search-deck-btn').addEventListener('click', () => { // 山札からサーチボタンのイベントリスナー
                const deckExpandedZoneEl = document.getElementById('deck-expanded-zone');
                if (deckExpandedZoneEl.style.display === 'flex') {
                    deckExpandedZoneEl.style.display = 'none';
                    shuffle(gameState.zones.deck); // 山札をシャッフル
                    alert('山札をシャッフルしました。');
                    renderAll(); // 表示を更新
                } else {
                    deckExpandedZoneEl.style.display = 'flex';
                    renderAll(); // 展開ゾーンのカードを再描画
                }
            });
            document.getElementById('search-volnoise-btn').addEventListener('click', () => { // VOLノイズからサーチボタンのイベントリスナー
                const volNoiseExpandedZoneEl = document.getElementById('volnoise-expanded-zone');
                if (volNoiseExpandedZoneEl.style.display === 'flex') {
                    volNoiseExpandedZoneEl.style.display = 'none';
                } else {
                    volNoiseExpandedZoneEl.style.display = 'flex';
                }
                renderAll(); // 展開ゾーンのカードを再描画
            });
            document.getElementById('open-temporary-zone-btn').addEventListener('click', () => {
                const temporaryExpandedZoneEl = document.getElementById('temporary-expanded-zone');
                if (temporaryExpandedZoneEl.style.display === 'flex') {
                    temporaryExpandedZoneEl.style.display = 'none';
                } else {
                    temporaryExpandedZoneEl.style.display = 'flex';
                }
                renderAll();
            });
            document.getElementById('temp-to-trash-btn').addEventListener('click', () => {
                if (gameState.zones.temporary.length > 0) {
                    gameState.zones.trash.push(...gameState.zones.temporary);
                    gameState.zones.temporary = [];
                    renderAll();
                    const temporaryExpandedZoneEl = document.getElementById('temporary-expanded-zone');
                    temporaryExpandedZoneEl.style.display = 'none'; // ゾーンを閉じる
                }
            });
            document.getElementById('temp-to-deck-shuffle-btn').addEventListener('click', () => {
                if (gameState.zones.temporary.length > 0) {
                    gameState.zones.deck.push(...gameState.zones.temporary);
                    gameState.zones.temporary = [];
                    shuffle(gameState.zones.deck);
                    renderAll();
                    const temporaryExpandedZoneEl = document.getElementById('temporary-expanded-zone');
                    temporaryExpandedZoneEl.style.display = 'none'; // ゾーンを閉じる
                }
            });
            document.getElementById('temp-to-deck-bottom-btn').addEventListener('click', () => {
                if (gameState.zones.temporary.length > 0) {
                    shuffle(gameState.zones.temporary); // まずテンポラリーゾーンのカードをシャッフル
                    gameState.zones.deck.unshift(...gameState.zones.temporary); // 山札の先頭（底）に追加
                    gameState.zones.temporary = [];
                    renderAll();
                }
            });
            document.getElementById('temp-hand-to-temporary-btn').addEventListener('click', () => { // 手札を全てテンポラリーゾーンへ送るボタン
                if (gameState.zones.hand.length > 0) {
                    gameState.zones.temporary.push(...gameState.zones.hand);
                    gameState.zones.hand = [];
                    renderAll();
                }
            });
            document.getElementById('turn-end-btn').addEventListener('click', () => {
                // ステージ上のカードのスタンバイ状態を解除
                gameState.zones.stage.forEach(column => {
                    ['green', 'blue', 'red'].forEach(color => {
                        if (column[color]) {
                            column[color].forEach(card => {
                                if (card.isStandby) {
                                    card.isStandby = false;
                                }
                            });
                        }
                    });
                });
                // ディレクションゾーンのカードのスタンバイ状態を解除
                gameState.zones.direction.forEach(slotArray => {
                    if (slotArray) {
                        slotArray.forEach(card => {
                            if (card.isStandby) {
                                card.isStandby = false;
                            }
                        });
                    }
                });
                // ターンカウンターを進める
                gameState.counters.turn++;
                renderAll();
            });
            document.getElementById('reset-btn').addEventListener('click', () => {
                if (confirm('ゲームをリセットしますか？')) window.location.reload();
            });
            document.getElementById('change-mat-btn').addEventListener('click', changeBackground);

            // 山札の下からドローボタンのイベントリスナー
            document.getElementById('draw-bottom-deck-btn').addEventListener('click', () => {
                if (gameState.zones.deck.length > 0) {
                    const bottomCard = gameState.zones.deck.shift(); // 配列の先頭（一番下）のカードを取り出す
                    if (bottomCard) {
                        // テンポラリーゾーンが開いているか確認
                        const temporaryExpandedZoneEl = document.getElementById('temporary-expanded-zone');
                        if (temporaryExpandedZoneEl.style.display === 'flex') {
                            gameState.zones.temporary.push(bottomCard);
                        } else {
                            gameState.zones.hand.push(bottomCard);
                        }
                        renderAll();
                    }
                } else {
                    alert('山札がありません。');
                }
            });

            let isRolling = false; // ローリング中フラグ
            // let diceTimer; // タイマーIDを保持

            // ダイスロールボタンのイベントリスナー
            document.getElementById('roll-dice-btn').addEventListener('click', () => {
                const diceContainerEl = document.getElementById('dice-container');
                const diceResultEl = document.createElement('div'); // 新しいダイス要素を作成
                diceResultEl.className = 'dice-result';

                const roll = Math.floor(Math.random() * 6) + 1; // 1～6の乱数
                diceResultEl.style.backgroundImage = `url('item/dice${roll}.png')`; // 画像変更
                diceResultEl.style.display = 'flex';
                diceContainerEl.appendChild(diceResultEl); // コンテナに追加

                setTimeout(() => {
                    diceResultEl.style.opacity = '0'; // 透明にする
                    setTimeout(() => {
                        diceResultEl.remove(); // DOMから削除
                    }, 1000); // フェードアウト時間
                }, 1500);

                // if (isRolling) {
                //     // 既にローリング中の場合は、少し暗くする
                //     diceResultEl.style.filter = 'brightness(50%)';
                //     clearTimeout(diceTimer); // タイマーをリセット
                //     setTimeout(() => {
                //         diceResultEl.style.filter = 'brightness(100%)'; // 元に戻す
                //     }, 200);
                // }

                // isRolling = true;
                // diceResultEl.style.display = 'flex'; // 表示

                // const roll = Math.floor(Math.random() * 6) + 1; // 1～6の乱数
                // diceResultEl.style.backgroundImage = `url('item/dice${roll}.png')`; // 画像変更

                // diceTimer = setTimeout(() => {
                //     diceResultEl.style.display = 'none'; // 1.5秒後に非表示
                //     isRolling = false;
                // }, 1500);
            });

            // ドキュメント全体のクリックで展開トラッシュゾーンを閉じる処理
            document.addEventListener('click', (event) => {
                const trashExpandedZoneEl = document.getElementById('trash-expanded-zone');
                const trashZoneEl = document.getElementById('trash-zone'); // トラッシュパイルの要素
                const deckExpandedZoneEl = document.getElementById('deck-expanded-zone'); // 山札展開ゾーンの要素
                const searchDeckBtnEl = document.getElementById('search-deck-btn'); // 山札サーチボタンの要素
                const volNoiseExpandedZoneEl = document.getElementById('volnoise-expanded-zone'); // VOLノイズ展開ゾーンの要素
                const searchVolNoiseBtnEl = document.getElementById('search-volnoise-btn'); // VOLノイズサーチボタンの要素
                const temporaryExpandedZoneEl = document.getElementById('temporary-expanded-zone'); // テンポラリー展開ゾーンの要素
                const openTemporaryBtnEl = document.getElementById('open-temporary-zone-btn'); // テンポラリーゾーンを開くボタンの要素

                // 展開トラッシュゾーンが表示されているか確認
                if (trashExpandedZoneEl.style.display === 'flex') {
                    // クリックがトラッシュパイルアイコン（トグルボタンとして機能）で発生したか確認
                    if (trashZoneEl.contains(event.target)) {
                        // トラッシュパイルアイコンがクリックされた場合は、既存のhandleTapに任せる
                        return;
                    }
                    // クリックが展開トラッシュゾーン内部で発生したか確認
                    if (trashExpandedZoneEl.contains(event.target)) {
                        // 展開トラッシュゾーン内部のクリックは無視（カード操作のため）
                        return;
                    }
                    trashExpandedZoneEl.style.display = 'none';
                }

                // 展開山札ゾーンが表示されているか確認
                if (deckExpandedZoneEl.style.display === 'flex') {
                    // クリックが山札サーチボタンで発生したか確認
                    if (searchDeckBtnEl.contains(event.target)) {
                        // 山札サーチボタンがクリックされた場合は、ボタンのイベントリスナーに任せる
                        return;
                    }
                    // クリックが展開山札ゾーン内部で発生したか確認
                    if (deckExpandedZoneEl.contains(event.target)) {
                        // 展開山札ゾーン内部のクリックは無視（カード操作のため）
                        return;
                    }
                    deckExpandedZoneEl.style.display = 'none';
                    shuffle(gameState.zones.deck); // 山札をシャッフル
                    alert('山札をシャッフルしました。');
                    renderAll(); // 表示を更新
                }

                // 展開VOLノイズゾーンが表示されているか確認
                if (volNoiseExpandedZoneEl.style.display === 'flex') {
                    // クリックがVOLノイズサーチボタンで発生したか確認
                    if (searchVolNoiseBtnEl.contains(event.target)) {
                        return;
                    }
                    // クリックが展開VOLノイズゾーン内部で発生したか確認
                    if (volNoiseExpandedZoneEl.contains(event.target)) {
                        return;
                    }
                    volNoiseExpandedZoneEl.style.display = 'none';
                }

                // 展開テンポラリーゾーンが表示されているか確認
                if (temporaryExpandedZoneEl.style.display === 'flex') {
                    if (openTemporaryBtnEl.contains(event.target) || temporaryExpandedZoneEl.contains(event.target)) {
                        // 開くボタン自身、またはゾーン内部（ボタンやカードエリア含む）のクリックは無視
                        return;
                    }
                    temporaryExpandedZoneEl.style.display = 'none';
                }
            });
        }

        function changeBackground() {
            if (document.body.style.backgroundImage.includes('wall.png')) {
                document.body.style.backgroundImage = "url('item/wall1.png')";
            } else {
                document.body.style.backgroundImage = "url('item/wall.png')";
            }
        }

        document.getElementById('start-game-btn').addEventListener('click', () => {
            const deckList = document.getElementById('deck-string').value.trim().split('/').filter(id => id);
            if (deckList.length === 0) {
                alert('有効なデッキリストを入力してください。');
                return;
            }
            initGameState(deckList);
            document.getElementById('deck-input-screen').style.display = 'none';
            document.getElementById('game-board').style.display = 'flex';
            setupEventListeners();
            renderAll();
        });

        // Initialize with default deck

        initGameState(document.getElementById('deck-string').value.trim().split('/').filter(id => id));
        renderAll();
    });
    </script>
</body>
</html>