<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>KAMITSUBAKI CARD GAME 一人回し用シミュレーター</title>
    <style>
        :root {
            --card-height: 19vh;
            --card-width: calc(var(--card-height) * 0.7);
            --zone-bg: rgba(0, 0, 0, 0.2);
            --border-color: rgba(255, 255, 255, 0.3);
        }
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background-color: #1a1a1d; color: #fff;
            font-family: 'Yu Gothic', 'Hiragino Kaku Gothic ProN', Meiryo, sans-serif;
            overflow: hidden; user-select: none; -webkit-user-select: none;
        }
        #game-container { width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; }
        .screen { width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 1vh 2vw; box-sizing: border-box; }
        #deck-input-screen { background-color: #2c2f33; }
        #deck-input-screen h1 { font-size: 1.2rem; margin-bottom: 15px; }
        #deck-string { width: 90%; max-width: 500px; height: 150px; font-size: 1rem; padding: 10px; margin-bottom: 15px; background-color: #40444b; border: 1px solid var(--border-color); color: #fff; }
        #start-game-btn { padding: 12px 25px; font-size: 1.1rem; cursor: pointer; background-color: #c90063; border: none; color: white; border-radius: 5px; }

        #game-board { display: none; width: 100%; height: 100%; flex-direction: column; }
        #main-area { display: flex; flex-grow: 1; height: calc(100% - var(--card-height) - 2vh); gap: 1vw; }
        #left-column { display: flex; flex-direction: column; justify-content: space-around; padding: 5px; gap: 1.5vh; }
        #center-column { flex-grow: 1; display: flex; flex-direction: column; padding: 5px 0; gap: 1vh; }
        #right-column { display: flex; flex-direction: column; align-items: center; padding: 5px; gap: 1vh; }

        .zone { border: 1px solid var(--border-color); border-radius: 5px; background-color: var(--zone-bg); position: relative; }
        .zone-title { position: absolute; top: -1.5vh; left: 5px; background: #1a1a1d; padding: 0 5px; font-size: 1.5vh; color: #ccc; z-index: 10; }
        .pile-zone { width: calc(var(--card-width) + 10px); height: calc(var(--card-height) + 10px); cursor: pointer; }
        
        #stage-zone, #direction-zone { display: flex; justify-content: space-around; align-items: center; flex-grow: 1; }
        .stage-column { position: relative; width: var(--card-width); height: calc(var(--card-height) * 2); }
        
        /* ### MODIFIED SECTION START ### */
        .card-slot {
            position: relative; /* この一行を追加しました */
            width: var(--card-width);
            height: var(--card-height);
            border: 1px dashed var(--border-color);
            border-radius: 4px;
            box-sizing: border-box;
        }
        /* ### MODIFIED SECTION END ### */

        .stage-column .card-slot { position: absolute; left: 0; }
        .card-slot[data-slot-color="green"]  { top: 0; border-color: #28a745; z-index: 1; }
        .card-slot[data-slot-color="blue"]   { top: calc(var(--card-height) * 0.5); border-color: #007bff; z-index: 2; }
        .card-slot[data-slot-color="red"]    { top: calc(var(--card-height) * 1.0); border-color: #dc3545; z-index: 3; }
        #direction-zone .card-slot { border-color: #e83e8c; }
        .card-slot .card { position: absolute; top: 0; left: 0; }
        
        #hand-zone { width: 100%; height: calc(var(--card-height) + 2vh); border-top: 1px solid var(--border-color); display: flex; justify-content: center; align-items: center; gap: 0.5vw; padding: 1vh 0; }
        .pile-zone .card { position: absolute; top: 5px; left: 5px; pointer-events: none; }
        .pile-zone .card:nth-child(2) { transform: translate(1px, 1px); }
        .pile-zone .card:nth-child(3) { transform: translate(2px, 2px); }
        .zone-count { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 4vh; font-weight: bold; color: white; text-shadow: 0 0 5px black, 0 0 5px black; pointer-events: none; }

        .card { width: var(--card-width); height: var(--card-height); background-size: cover; background-position: center; background-repeat: no-repeat; border-radius: 4px; transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease; cursor: grab; touch-action: none; transform-origin: center; }
        .card.dragging { position: fixed; z-index: 3000; cursor: grabbing; box-shadow: 0 0 15px rgba(255, 255, 255, 0.5); pointer-events: none; transition: none; }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="deck-input-screen" class="screen">
            <h1>KAMITSUBAKI CARD GAME</h1>
            <p>デッキリストを / 区切りで入力してください</p>
            <textarea id="deck-string" placeholder="例: AA-01/AA-01/AA-02/...">DA-26/DA-26/DA-26/DA-26/BS-34/BS-34/BS-34/BS-34/GS-19/GS-19/GS-19/GS-19/AS-1/AS-1/AS-1/AS-1/AS-3/AS-3/AS-3/AS-3/GS-41/GS-41/GS-41/GS-41/AD-2/AD-2/AD-2/AD-3/AD-3/AD-3/BD-8/BD-8/BD-8/BD-15/BD-15/BD-15/GD-12/GD-12/GD-12/GD-14/prmM-1/prmM-1/prmM-1/prmM-1/AM-1/AM-1/AM-1/AM-1/AM-7/AM-7/BM-2/BM-2/BM-3/BM-3/BM-3/BM-3/DM-22/DM-22/DM-22/DM-22</textarea>
            <button id="start-game-btn">ゲーム開始</button>
        </div>
        <div id="game-board" class="screen">
            <div id="main-area">
                <div id="left-column">
                    <div id="deck-zone" class="zone pile-zone drop-zone" data-zone-id="deck"><div class="zone-title">山札</div></div>
                    <div id="trash-zone" class="zone pile-zone drop-zone" data-zone-id="trash"><div class="zone-title">トラッシュ</div></div>
                </div>
                <div id="center-column">
                    <div id="stage-zone" class="zone">
                        <div class="zone-title">ステージ</div>
                        <div class="stage-column"><div class="card-slot drop-zone" data-zone-id="stage" data-slot-index="0" data-slot-color="green"></div><div class="card-slot drop-zone" data-zone-id="stage" data-slot-index="0" data-slot-color="blue"></div><div class="card-slot drop-zone" data-zone-id="stage" data-slot-index="0" data-slot-color="red"></div></div>
                        <div class="stage-column"><div class="card-slot drop-zone" data-zone-id="stage" data-slot-index="1" data-slot-color="green"></div><div class="card-slot drop-zone" data-zone-id="stage" data-slot-index="1" data-slot-color="blue"></div><div class="card-slot drop-zone" data-zone-id="stage" data-slot-index="1" data-slot-color="red"></div></div>
                        <div class="stage-column"><div class="card-slot drop-zone" data-zone-id="stage" data-slot-index="2" data-slot-color="green"></div><div class="card-slot drop-zone" data-zone-id="stage" data-slot-index="2" data-slot-color="blue"></div><div class="card-slot drop-zone" data-zone-id="stage" data-slot-index="2" data-slot-color="red"></div></div>
                        <div class="stage-column"><div class="card-slot drop-zone" data-zone-id="stage" data-slot-index="3" data-slot-color="green"></div><div class="card-slot drop-zone" data-zone-id="stage" data-slot-index="3" data-slot-color="blue"></div><div class="card-slot drop-zone" data-zone-id="stage" data-slot-index="3" data-slot-color="red"></div></div>
                        <div class="stage-column"><div class="card-slot drop-zone" data-zone-id="stage" data-slot-index="4" data-slot-color="green"></div><div class="card-slot drop-zone" data-zone-id="stage" data-slot-index="4" data-slot-color="blue"></div><div class="card-slot drop-zone" data-zone-id="stage" data-slot-index="4" data-slot-color="red"></div></div>
                    </div>
                    <div id="direction-zone" class="zone">
                        <div class="zone-title">Direction</div>
                        <div class="card-slot drop-zone" data-zone-id="direction" data-slot-index="0"></div>
                        <div class="card-slot drop-zone" data-zone-id="direction" data-slot-index="1"></div>
                        <div class="card-slot drop-zone" data-zone-id="direction" data-slot-index="2"></div>
                        <div class="card-slot drop-zone" data-zone-id="direction" data-slot-index="3"></div>
                        <div class="card-slot drop-zone" data-zone-id="direction" data-slot-index="4"></div>
                    </div>
                </div>
                <div id="right-column">
                    <div class="counter"><div class="counter-label">VOL</div><div class="counter-controls"><button class="counter-btn" data-counter="vol" data-amount="-1">-</button><span id="vol-value" class="counter-value">0</span><button class="counter-btn" data-counter="vol" data-amount="1">+</button></div></div>
                    <div class="counter"><div class="counter-label">魔力 α</div><div class="counter-controls"><button class="counter-btn" data-counter="manaAlpha" data-amount="-1">-</button><span id="mana-alpha-value" class="counter-value">0</span><button class="counter-btn" data-counter="manaAlpha" data-amount="1">+</button></div></div>
                    <div class="counter"><div class="counter-label">魔力 β</div><div class="counter-controls"><button class="counter-btn" data-counter="manaBeta" data-amount="-1">-</button><span id="mana-beta-value" class="counter-value">0</span><button class="counter-btn" data-counter="manaBeta" data-amount="1">+</button></div></div>
                    <div class="counter"><div class="counter-label">魔力 Ω</div><div class="counter-controls"><button class="counter-btn" data-counter="manaOmega" data-amount="-1">-</button><span id="mana-omega-value" class="counter-value">0</span><button class="counter-btn" data-counter="manaOmega" data-amount="1">+</button></div></div>
                    <div class="counter"><div class="counter-label">ターン</div><div class="counter-controls"><button class="counter-btn" data-counter="turn" data-amount="-1">-</button><span id="turn-value" class="counter-value">1</span><button class="counter-btn" data-counter="turn" data-amount="1">+</button></div></div>
                    <button id="shuffle-btn" class="action-btn">山札シャッフル</button>
                    <button id="reset-btn" class="action-btn">リセット</button>
                </div>
            </div>
            <div id="hand-zone" class="zone drop-zone" data-zone-id="hand"></div>
        </div>
    </div>
    
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const counters = { vol: document.getElementById('vol-value'), manaAlpha: document.getElementById('mana-alpha-value'), manaBeta: document.getElementById('mana-beta-value'), manaOmega: document.getElementById('mana-omega-value'), turn: document.getElementById('turn-value'), };
        let gameState = {};
        function initGameState(deckList = []) {
            const NUM_SLOTS = 5;
            gameState = {
                counters: { turn: 1, vol: 0, manaAlpha: 0, manaBeta: 0, manaOmega: 0 },
                zones: {
                    deck: shuffle([...deckList]), hand: [],
                    stage: Array(NUM_SLOTS).fill(null).map(() => ({ red: [], blue: [], green: [] })),
                    direction: Array(NUM_SLOTS).fill(null).map(() => []),
                    trash: [],
                }
            };
            for(let i = 0; i < 7; i++) { if (gameState.zones.deck.length > 0) { gameState.zones.hand.push(gameState.zones.deck.pop()); } }
        }

        let draggedCardVisual = null, draggedCardData = null, sourceInfo = null;
        let isDragging = false;
        const CARD_IMAGE_PATH = 'cards/';

        function shuffle(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[array[i], array[j]] = [array[j], array[i]]; } return array; }
        
        function removeCardFromState(cardData, fromInfo) {
            if (!cardData || !fromInfo) return;
            const zoneId = fromInfo.zoneId;
            const cardIdToRemove = cardData.cardId;
            let slotArray;
            if (zoneId === 'direction') { slotArray = gameState.zones.direction[fromInfo.slotIndex]; }
            else if (zoneId === 'stage') { slotArray = gameState.zones.stage[fromInfo.slotIndex][fromInfo.slotColor]; }
            
            if (slotArray && slotArray.length > 0) {
                const topCard = slotArray[slotArray.length - 1];
                if (topCard.cardId === cardIdToRemove) {
                    slotArray.pop();
                }
            } else if (zoneId !== 'direction' && zoneId !== 'stage') { 
                const zone = gameState.zones[zoneId]; 
                if(!zone) return; 
                const index = zone.indexOf(cardIdToRemove); 
                if (index > -1) zone.splice(index, 1); 
            }
        }
        function addCardToState(cardData, toInfo) {
            if (!cardData || !toInfo || !toInfo.zoneId) return;
            const zoneId = toInfo.zoneId;
            const cardObject = { cardId: cardData.cardId, isStandby: false };
            
            if (zoneId === 'direction') {
                if(toInfo.slotIndex !== undefined) gameState.zones.direction[toInfo.slotIndex].push(cardObject);
            } else if (zoneId === 'stage') {
                if(toInfo.slotIndex !== undefined && toInfo.slotColor) gameState.zones.stage[toInfo.slotIndex][toInfo.slotColor].push(cardObject);
            } else {
                const zone = gameState.zones[zoneId];
                if(zone && typeof cardObject.cardId === 'string') zone.push(cardObject.cardId);
            }
        }

        function renderAll() {
            renderBoard();
        }

        function renderBoard() {
            document.querySelectorAll('.card, .zone-count').forEach(el => el.remove());
            ['deck', 'trash'].forEach(zoneId => {
                const zoneEl = document.getElementById(`${zoneId}-zone`);
                const zoneData = gameState.zones[zoneId];
                if (zoneData.length > 0) {
                    zoneEl.appendChild(createCardElement(zoneData.slice(-1)[0], false, zoneId, 'none'));
                    const countEl = document.createElement('span'); countEl.className = 'zone-count';
                    countEl.textContent = zoneData.length; zoneEl.appendChild(countEl);
                }
            });

            document.getElementById('hand-zone').innerHTML = '';
            gameState.zones.hand.forEach(cardId => { document.getElementById('hand-zone').appendChild(createCardElement(cardId, false, 'hand', 'drag')); });
            
            gameState.zones.direction.forEach((cardArray, index) => {
                const slotEl = document.querySelector(`.card-slot[data-zone-id="direction"][data-slot-index="${index}"]`);
                if (slotEl && cardArray.length > 0) {
                    cardArray.forEach((card, i) => {
                        const cardElement = createCardElement(card.cardId, false, 'direction', 'drag', index);
                        let transformString = `translate(${i * 2}px, ${i * 2}px)`;
                        cardElement.style.transform = transformString;
                        cardElement.style.zIndex = i;
                        slotEl.appendChild(cardElement);
                    });
                }
            });
            gameState.zones.stage.forEach((column, index) => {
                ['green', 'blue', 'red'].forEach(color => {
                    const cardArray = column[color];
                    const slotEl = document.querySelector(`.card-slot[data-zone-id="stage"][data-slot-index="${index}"][data-slot-color="${color}"]`);
                    if (slotEl && cardArray.length > 0) {
                        cardArray.forEach((card, i) => {
                           const cardElement = createCardElement(card.cardId, false, 'stage', 'drag', index, color);
                           let transformString = `translate(${i * 2}px, ${i * 2}px)`;
                           cardElement.style.transform = transformString;
                           cardElement.style.zIndex = i;
                           slotEl.appendChild(cardElement);
                        });
                    }
                });
            });
            for (const counterId in counters) { counters[counterId].textContent = gameState.counters[counterId]; }
        }
        
        function createCardElement(cardId, isStandby, zoneId, interactiveType, slotIndex, slotColor) {
            const cardEl = document.createElement('div');
            cardEl.className = 'card';
            if(!cardId) return cardEl;
            
            cardEl.dataset.cardId = cardId;
            if (slotIndex !== undefined) cardEl.dataset.slotIndex = slotIndex;
            if (slotColor) cardEl.dataset.slotColor = slotColor;
            
            if(zoneId === 'deck') { cardEl.style.backgroundImage = `url('${CARD_IMAGE_PATH}back.png')`; }
            else { cardEl.style.backgroundImage = `url('${CARD_IMAGE_PATH}${cardId}.png')`; }

            if (interactiveType === 'drag') {
                cardEl.addEventListener('mousedown', handlePressStart);
                cardEl.addEventListener('touchstart', handlePressStart, { passive: false });
            }
            return cardEl;
        }
        
        function handlePressStart(e) {
            e.preventDefault();
            const element = e.currentTarget;
            let zoneId, isPile = false;

            if (element.classList.contains('pile-zone')) {
                isPile = true;
                zoneId = element.dataset.zoneId;
            } else if (element.classList.contains('card')) {
                const parentZone = element.closest('.drop-zone');
                if(!parentZone) return;
                zoneId = parentZone.dataset.zoneId;
            } else { return; }
            sourceInfo = { zoneId };
            
            if (isPile) {
                if (gameState.zones[zoneId].length === 0) return;
                draggedCardData = { cardId: gameState.zones[zoneId].slice(-1)[0], isStandby: false };
            } else {
                 const cardId = element.dataset.cardId;
                 if (['hand', 'trash'].includes(zoneId)) {
                    draggedCardData = { cardId: cardId, isStandby: false };
                 } else { 
                    sourceInfo.slotIndex = element.dataset.slotIndex;
                    let slotArray;
                    if(zoneId === 'stage') {
                        sourceInfo.slotColor = element.dataset.slotColor;
                        slotArray = gameState.zones.stage[sourceInfo.slotIndex][sourceInfo.slotColor];
                    } else if (zoneId === 'direction') {
                        slotArray = gameState.zones.direction[sourceInfo.slotIndex];
                    }
                    if(!slotArray || slotArray.length === 0) return;
                    draggedCardData = { ...slotArray[slotArray.length - 1] };
                 }
            }
            if(!draggedCardData) return;

            let isDragging = false;
            const touch = e.touches ? e.touches[0] : e;
            const rect = element.getBoundingClientRect();
            let offsetX = touch.clientX - rect.left; let offsetY = touch.clientY - rect.top;
            if (isPile) { offsetX = rect.width / 2; offsetY = rect.height / 2; }
            
            const onMove = (moveEvent) => {
                if (!isDragging) {
                    isDragging = true;
                    if(!isPile) { element.style.opacity = '0.5'; }
                    draggedCardVisual = document.createElement('div');
                    draggedCardVisual.className = 'card dragging';
                    draggedCardVisual.style.backgroundImage = `url('${CARD_IMAGE_PATH}${draggedCardData.cardId}.png')`;
                    document.body.appendChild(draggedCardVisual);
                }
                const moveTouch = moveEvent.touches ? moveEvent.touches[0] : moveEvent;
                draggedCardVisual.style.left = `${moveTouch.clientX - offsetX}px`;
                draggedCardVisual.style.top = `${moveTouch.clientY - offsetY}px`;
            };
            const onEnd = (endEvent) => {
                document.removeEventListener('mousemove', onMove); document.removeEventListener('touchmove', onMove);
                document.removeEventListener('mouseup', onEnd); document.removeEventListener('touchend', onEnd);
                if (!isPile) element.style.opacity = '1';

                if (isDragging) {
                    removeCardFromState(draggedCardData, sourceInfo);
                    draggedCardVisual.style.display = 'none';
                    const endX = (endEvent.changedTouches ? endEvent.changedTouches[0] : endEvent).clientX;
                    const endY = (endEvent.changedTouches ? endEvent.changedTouches[0] : endEvent).clientY;
                    const targetEl = document.elementFromPoint(endX, endY);
                    
                    let dropped = false;
                    const targetSlot = targetEl ? targetEl.closest('.card-slot.drop-zone') : null;
                    const targetNonSlotZone = targetEl ? targetEl.closest('.zone.drop-zone:not(#stage-zone):not(#direction-zone)') : null;

                    if(targetSlot) {
                        const targetInfo = { zoneId: targetSlot.dataset.zoneId, slotIndex: targetSlot.dataset.slotIndex, slotColor: targetSlot.dataset.slotColor };
                        addCardToState(draggedCardData, targetInfo); dropped = true;
                    } else if (targetNonSlotZone) {
                        addCardToState(draggedCardData, { zoneId: targetNonSlotZone.dataset.zoneId }); dropped = true;
                    }
                    if(!dropped) { addCardToState(draggedCardData, sourceInfo); }
                }

                if (draggedCardVisual) draggedCardVisual.remove();
                draggedCardVisual = null; draggedCardData = null; sourceInfo = null; isDragging = false;
                renderAll();
            };
            document.addEventListener('mousemove', onMove);
            document.addEventListener('touchmove', onMove, { passive: false });
            document.addEventListener('mouseup', onEnd);
            document.addEventListener('touchend', onEnd);
        }
        
        function setupEventListeners() {
            document.getElementById('start-game-btn').addEventListener('click', () => {
                const deckList = document.getElementById('deck-string').value.trim().split('/').filter(id => id);
                if (deckList.length === 0) { alert('有効なデッキリストを入力してください。'); return; }
                initGameState(deckList);
                document.getElementById('deck-input-screen').style.display = 'none';
                document.getElementById('game-board').style.display = 'flex';
                renderAll();
            });
            document.getElementById('reset-btn').addEventListener('click', () => { if (confirm('ゲームをリセットしますか？')) window.location.reload(); });
            document.getElementById('shuffle-btn').addEventListener('click', () => { shuffle(gameState.zones.deck); renderAll(); alert('山札をシャッフルしました。'); });
            
            document.querySelectorAll('.counter-btn').forEach(btn => btn.addEventListener('click', () => { const counter = btn.dataset.counter; gameState.counters[counter] += parseInt(btn.dataset.amount, 10); if (gameState.counters[counter] < 0) gameState.counters[counter] = 0; renderAll(); }));
            
            document.getElementById('deck-zone').addEventListener('mousedown', handlePressStart);
            document.getElementById('deck-zone').addEventListener('touchstart', handlePressStart, { passive: false });
            document.getElementById('trash-zone').addEventListener('mousedown', handlePressStart);
            document.getElementById('trash-zone').addEventListener('touchstart', handlePressStart, { passive: false });
        }
        
        initGameState();
        setupEventListeners();
    });
    </script>
</body>
</html>